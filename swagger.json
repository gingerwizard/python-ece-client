{
  "swagger": "2.0",
  "info": {
    "description": "",
    "version": "",
    "title": "",
    "termsOfService": ""
  },
  "host": "localhost",
  "basePath": "/api/v1/",
  "tags": [
    {
      "name": "ClustersElasticsearch"
    },
    {
      "name": "ClustersKibana"
    },
    {
      "name": "Platform"
    },
    {
      "name": "PlatformConfigurationSecurity"
    },
    {
      "name": "PlatformConfigurationSnapshots"
    },
    {
      "name": "PlatformInfrastructure"
    },
    {
      "name": "Stack"
    }
  ],
  "schemes": [
    "http"
  ],
  "paths": {
    "/clusters/elasticsearch/{cluster_id}/_restart": {
      "post": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Restart cluster",
        "description": "Restarts an Elasticsearch cluster. If a cluster is active: this command re-applies the existing plan but applies a \"cluster_reboot\", which issues an Elasticsearch restart command and waits for it to complete. If a cluster is inactive: this command starts it up with the most recent successful plan.",
        "operationId": "restart-es-cluster",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "restore_snapshot",
            "in": "query",
            "description": "If restoring from shutdown and true (the default), then will restore the cluster from the last snapshot (if available)",
            "required": false,
            "type": "boolean",
            "default": true
          },
          {
            "name": "skip_snapshot",
            "in": "query",
            "description": "If true, will take a snapshot of the cluster before restarting (if possible)",
            "required": false,
            "type": "boolean",
            "default": true
          },
          {
            "name": "cancel_pending",
            "in": "query",
            "description": "If true, will cancel any pending plans before restarting (else will error)",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "group_attribute",
            "in": "query",
            "description": "Indicates the property or properties used to divide the list of instances to restart in groups. Valid options are: '\\_\\_all\\_\\_' (restart all at once), '\\_\\_zone\\_\\_' by logical zone, '\\_\\_name\\_\\_' one instance at the time, or a comma-separated list of attributes of the instances",
            "required": false,
            "type": "string",
            "default": "\\_\\_all\\_\\_"
          }
        ],
        "responses": {
          "202": {
            "description": "The stop command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "412": {
            "description": "The command sent to a cluster found the cluster in an illegal state, the error message gives more details (code: 'clusters.cluster_plan_state_error')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - Commands"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/_shutdown": {
      "post": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Shut down cluster",
        "description": "Shuts down a running cluster and removes all nodes belonging to the cluster. The plan for the cluster is retained. Warning: this will lose all cluster data that is not saved in a snapshot repository.",
        "operationId": "shutdown-es-cluster",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "skip_snapshot",
            "in": "query",
            "description": "If true, will skip taking a snapshot of the cluster before shutting the cluster down (if even possible)",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "hide",
            "in": "query",
            "description": "Hide cluster on shutdown. Hidden clusters are not listed by default.",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The shutdown command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - Commands"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/instances/{instance_ids}/_start": {
      "post": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Start instances",
        "description": "Starts the instances belonging to an Elasticsearch cluster",
        "operationId": "start-es-cluster-instances",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "instance_ids",
            "in": "path",
            "description": "Optional comma-delimited list of instance identifiers of the Elasticsearch cluster, otherwise will apply to all instances",
            "required": true,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The start command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "403": {
            "description": "The start command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "One or more of the instances specified at {instance_ids} could not be found (code: 'clusters.instances_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - Commands"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/instances/{instance_ids}/_move": {
      "post": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Move instances",
        "description": "Moves one or more instances belonging to an Elasticsearch cluster",
        "operationId": "move-es-cluster-instances",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Overrides defaults for the move, including setting the configuration of instances specified in the path",
            "required": false,
            "schema": {
              "$ref": "#/definitions/TransientElasticsearchPlanConfiguration"
            }
          },
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "instance_ids",
            "in": "path",
            "description": "Optional comma-delimited list of instance identifiers of the Elasticsearch cluster, otherwise will apply to all instances",
            "required": true,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "force_update",
            "in": "query",
            "description": "If true, will cancel any pending plans and overwrite with this move plan, else will error",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "instances_down",
            "in": "query",
            "description": "If true the the instances specified by 'instance_ids' will be considered to be permanently down for the purposes of data migration logic",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "validate_only",
            "in": "query",
            "description": "If true, will validate the move request and return the calculated plan without actually applying it.",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The move command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "400": {
            "description": "The cluster definition contained errors (code: 'clusters.cluster_invalid_plan' and 'clusters.plan_feature_not_implemented')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "403": {
            "description": "The move command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "One or more of the instances specified at {instance_ids} could not be found (code: 'clusters.instances_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - Commands"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/instances/_move": {
      "post": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Move instances (advanced)",
        "description": "Moves one or more instances belonging to an Elasticsearch cluster, with custom configuration posted in the body",
        "operationId": "move-es-cluster-instances-advanced",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Overrides defaults for the move, including setting the configuration of instances specified in the path",
            "required": true,
            "schema": {
              "$ref": "#/definitions/TransientElasticsearchPlanConfiguration"
            }
          },
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "force_update",
            "in": "query",
            "description": "If true, will cancel any pending plans and overwrite with this move plan, else will error",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "instances_down",
            "in": "query",
            "description": "If true the the instances specified by 'instance_ids' will be considered to be permanently down for the purposes of data migration logic",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "validate_only",
            "in": "query",
            "description": "If true, will validate the move request and return the calculated plan without actually applying it.",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The move command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "400": {
            "description": "The cluster definition contained errors (code: 'clusters.cluster_invalid_plan' and 'clusters.plan_feature_not_implemented')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "403": {
            "description": "The move command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "One or more of the instances specified at {instance_ids} could not be found (code: 'clusters.instances_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - Commands"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/instances/{instance_ids}/_stop": {
      "post": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Stop instances",
        "description": "Stops the instances belonging to an Elasticsearch cluster.",
        "operationId": "stop-es-cluster-instances",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "instance_ids",
            "in": "path",
            "description": "Optional comma-delimited list of instance identifiers of the Elasticsearch cluster, otherwise will apply to all instances",
            "required": true,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The stop command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "403": {
            "description": "The stop command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "One or more of the instances specified at {instance_ids} could not be found (code: 'clusters.instances_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - Commands"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/instances/{instance_ids}/maintenance-mode/_start": {
      "post": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Start maintenance mode",
        "description": "Starts maintenance mode of instances belonging to an Elasticsearch cluster.",
        "operationId": "start-es-cluster-maintenance-mode",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "instance_ids",
            "in": "path",
            "description": "Optional comma-delimited list of instance identifiers of the Elasticsearch cluster, otherwise will apply to all instances",
            "required": true,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The start maintenance mode command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "403": {
            "description": "The start maintenance mode command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "One or more of the instances specified at {instance_ids} could not be found (code: 'clusters.instances_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - Commands"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/instances/{instance_ids}/maintenance-mode/_stop": {
      "post": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Stop maintenance mode",
        "description": "Stops maintenance mode of instances belonging to an Elasticsearch cluster.",
        "operationId": "stop-es-cluster-maintenance-mode",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "instance_ids",
            "in": "path",
            "description": "Optional comma-delimited list of instance identifiers of the Elasticsearch cluster, otherwise will apply to all instances",
            "required": true,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The stop maintenance mode command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "403": {
            "description": "The stop maintenance mode command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "One or more of the instances specified at {instance_ids} could not be found (code: 'clusters.instances_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - Commands"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/_restart": {
      "post": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Restart cluster",
        "description": "Restarts a Kibana cluster. If a cluster is active: this command re-applies the existing plan but applies a \"cluster_reboot\", which issues a Kibana restart command and waits for it to complete. If a cluster is inactive: this command starts it up with the most recent successful plan.",
        "operationId": "restart-kibana-cluster",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "cancel_pending",
            "in": "query",
            "description": "If true, will cancel any pending plans before restarting (else will error)",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The stop command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "412": {
            "description": "The command sent to a cluster found the cluster in an illegal state, the error message gives more details (code: 'clusters.cluster_plan_state_error')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - Commands"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/_shutdown": {
      "post": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Shut down cluster",
        "description": "Shuts down a running cluster and removes all nodes belonging to the cluster. The cluster definition is retained. Warning: this will lose all cluster data that is not saved in a snapshot repository.",
        "operationId": "shutdown-kibana-cluster",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "hide",
            "in": "query",
            "description": "Hide cluster on shutdown. Hidden clusters are not listed by default.",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The shutdown command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - Commands"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/instances/{instance_ids}/_start": {
      "post": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Start instances",
        "description": "Starts the instances belonging to a Kibana cluster.",
        "operationId": "start-kibana-cluster-instances",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "instance_ids",
            "in": "path",
            "description": "Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances",
            "required": true,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The start command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "403": {
            "description": "The start command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "One or more of the instances specified at {instance_ids} could not be found (code: 'clusters.instances_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - Commands"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/instances/{instance_ids}/_move": {
      "post": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Move instances",
        "description": "Moves one or more instances belonging to a Kibana cluster",
        "operationId": "move-kibana-cluster-instances",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Overrides defaults for the move, including setting the configuration of instances specified in the path",
            "required": false,
            "schema": {
              "$ref": "#/definitions/TransientKibanaPlanConfiguration"
            }
          },
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "instance_ids",
            "in": "path",
            "description": "Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances",
            "required": true,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "force_update",
            "in": "query",
            "description": "If true, will cancel any pending plans and overwrite with this move plan, else will error",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "validate_only",
            "in": "query",
            "description": "If true, will validate the move request and return the calculated plan without actually applying it.",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The move command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "400": {
            "description": "The cluster definition contained errors (code: 'clusters.cluster_invalid_plan' and 'clusters.plan_feature_not_implemented')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "403": {
            "description": "The move command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "One or more of the instances specified at {instance_ids} could not be found (code: 'clusters.instances_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - Commands"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/instances/_move": {
      "post": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Move instances (advanced)",
        "description": "Moves one or more instances belonging to a Kibana cluster, with custom configuration posted in the body",
        "operationId": "move-kibana-cluster-instances-advanced",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Overrides defaults for the move, including setting the configuration of instances specified in the path",
            "required": true,
            "schema": {
              "$ref": "#/definitions/TransientKibanaPlanConfiguration"
            }
          },
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "force_update",
            "in": "query",
            "description": "If true, will cancel any pending plans and overwrite with this move plan, else will error",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "validate_only",
            "in": "query",
            "description": "If true, will validate the move request and return the calculated plan without actually applying it.",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The move command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "400": {
            "description": "The cluster definition contained errors (code: 'clusters.cluster_invalid_plan' and 'clusters.plan_feature_not_implemented')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "403": {
            "description": "The move command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "One or more of the instances specified at {instance_ids} could not be found (code: 'clusters.instances_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - Commands"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/instances/{instance_ids}/_stop": {
      "post": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Stop instances",
        "description": "Stops the instances belonging to a Kibana cluster.",
        "operationId": "stop-kibana-cluster-instances",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "instance_ids",
            "in": "path",
            "description": "Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances",
            "required": true,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The stop command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "403": {
            "description": "The stop command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "One or more of the instances specified at {instance_ids} could not be found (code: 'clusters.instances_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - Commands"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/instances/{instance_ids}/maintenance-mode/_start": {
      "post": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Start maintenance mode",
        "description": "Starts maintenance mode of instances belonging to a Kibana cluster.",
        "operationId": "start-kibana-cluster-maintenance-mode",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "instance_ids",
            "in": "path",
            "description": "Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances",
            "required": true,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The start maintenance mode command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "403": {
            "description": "The start maintenance mode command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "One or more of the instances specified at {instance_ids} could not be found (code: 'clusters.instances_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - Commands"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/instances/{instance_ids}/maintenance-mode/_stop": {
      "post": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Stop maintenance mode",
        "description": "Stops maintenance mode of instances belonging to a Kibana cluster.",
        "operationId": "stop-kibana-cluster-maintenance-mode",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "instance_ids",
            "in": "path",
            "description": "Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances",
            "required": true,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The stop maintenance mode command was issued successfully, use the \"GET\" command on the /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/ClusterCommandResponse"
            }
          },
          "403": {
            "description": "The stop maintenance mode command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "One or more of the instances specified at {instance_ids} could not be found (code: 'clusters.instances_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - Commands"
        }
      }
    },
    "/clusters/elasticsearch": {
      "get": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Get clusters",
        "description": "Retrieves cluster information for all Elasticsearch clusters.",
        "operationId": "get-es-clusters",
        "parameters": [
          {
            "name": "from",
            "in": "query",
            "description": "The number of clusters to skip over",
            "required": false,
            "type": "integer",
            "default": 0
          },
          {
            "name": "size",
            "in": "query",
            "description": "The maximum number of clusters to return (set to -1 for all clusters - use with care, can result in large responses)",
            "required": false,
            "type": "integer",
            "default": 100
          },
          {
            "name": "show_security",
            "in": "query",
            "description": "Whether to include the Elasticsearch 2.x security information in the response - can be large per cluster and also include credentials",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "show_metadata",
            "in": "query",
            "description": "Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "show_plans",
            "in": "query",
            "description": "Whether to include the full current and pending plan information in the response - can be large per cluster",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "show_plan_defaults",
            "in": "query",
            "description": "If showing plans, whether to show values that are left at their default value (less readable but more informative)",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "show_system_alerts",
            "in": "query",
            "description": "Number of system alerts (such as forced restarts due to memory limits) to be included in the response - can be large per cluster. Negative numbers or 0 will not return field.",
            "required": false,
            "type": "integer",
            "default": 0
          },
          {
            "name": "show_hidden",
            "in": "query",
            "description": "Whether to include hidden clusters in the response or not",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "Returning the specified set of clusters from the platform",
            "schema": {
              "$ref": "#/definitions/ElasticsearchClustersInfo"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD"
        }
      },
      "post": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Create cluster",
        "description": "Creates an Elasticsearch cluster.",
        "operationId": "create-es-cluster",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "The cluster definition",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CreateElasticsearchClusterRequest"
            }
          },
          {
            "name": "validate_only",
            "in": "query",
            "description": "If true, will just validate the cluster definition but will not perform the creation",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster definition was valid - no further action was requested. The return object contains an internal representation of the plan, for use in debugging",
            "schema": {
              "$ref": "#/definitions/ClusterCrudResponse"
            }
          },
          "201": {
            "description": "The cluster definition was valid and the cluster creation has started",
            "schema": {
              "$ref": "#/definitions/ClusterCrudResponse"
            }
          },
          "400": {
            "description": "The cluster definition contained errors (code: 'clusters.cluster_invalid_plan' and 'clusters.plan_feature_not_implemented')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/plan": {
      "get": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Get plan",
        "description": "Retrieves the active plan of an Elasticsearch cluster.",
        "operationId": "get-es-cluster-plan",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "show_plan_defaults",
            "in": "query",
            "description": "Whether to show values that are left at their default value (less readable but more informative)",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster has a current applied plan",
            "schema": {
              "$ref": "#/definitions/ElasticsearchClusterPlan"
            },
            "headers": {
              "x-cloud-resource-version": {
                "type": "string",
                "description": "The version of the resource - used to avoid update conflicts from multiple concurrent operations"
              },
              "x-cloud-resource-created": {
                "type": "string",
                "description": "The date-time when the resource was created (ISO format relative to UTC)"
              },
              "x-cloud-resource-last-modified": {
                "type": "string",
                "description": "The date-time when the resource was last modified (ISO format relative to UTC)"
              }
            }
          },
          "412": {
            "description": "There is not currently applied plan - eg the cluster has not finished provisioning, or the provisioning failed (code: 'clusters.cluster_plan_state_error')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      },
      "post": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Update plan",
        "description": "Updates the configuration of an existing Elasticsearch cluster.",
        "operationId": "update-es-cluster-plan",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "The update plan definition",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ElasticsearchClusterPlan"
            }
          },
          {
            "name": "validate_only",
            "in": "query",
            "description": "If true, will just validate the cluster definition but will not perform the update",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster definition was valid - no further action was requested. The return object contains an internal representation of the plan, for use in debugging",
            "schema": {
              "$ref": "#/definitions/ClusterCrudResponse"
            }
          },
          "202": {
            "description": "The plan definition was valid and the updated plan is in progress.",
            "schema": {
              "$ref": "#/definitions/ClusterCrudResponse"
            }
          },
          "400": {
            "description": "The cluster definition contained errors (code: 'clusters.cluster_invalid_plan' and 'clusters.plan_feature_not_implemented')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "412": {
            "description": "Potential risky settings have been specified (code: 'clusters.cluster_plan_state_error')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/plan/pending": {
      "get": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Get pending plan",
        "description": "Retrieves the pending plan of a cluster.",
        "operationId": "get-es-cluster-pending-plan",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "show_plan_defaults",
            "in": "query",
            "description": "Whether to show values that are left at their default value (less readable but more informative)",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster has a pending plan currently being applied to the cluster",
            "schema": {
              "$ref": "#/definitions/ElasticsearchClusterPlan"
            },
            "headers": {
              "x-cloud-resource-version": {
                "type": "string",
                "description": "The version of the resource - used to avoid update conflicts from multiple concurrent operations"
              },
              "x-cloud-resource-created": {
                "type": "string",
                "description": "The date-time when the resource was created (ISO format relative to UTC)"
              },
              "x-cloud-resource-last-modified": {
                "type": "string",
                "description": "The date-time when the resource was last modified (ISO format relative to UTC)"
              }
            }
          },
          "412": {
            "description": "There is not currently applied plan - eg the cluster has not finished provisioning, or the provisioning failed (code: 'clusters.cluster_plan_state_error')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      },
      "delete": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Cancel pending plan",
        "description": "Cancels the pending plan of an Elasticsearch cluster.",
        "operationId": "cancel-es-cluster-pending-plan",
        "parameters": [
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true, will return successfully regardless of whether there was a pending plan or not",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The pending plan has been successfully cancelled",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "412": {
            "description": "There is not currently applied plan - eg the cluster has not finished provisioning, or the provisioning failed (code: 'clusters.cluster_plan_state_error')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/instances/settings": {
      "put": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Set settings overrides (all instances)",
        "description": "Overrides settings for all instances belonging to an Elasticsearch cluster.",
        "operationId": "set-es-cluster-instances-all-settings-overrides",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "The settings to override for the instances.",
            "required": false,
            "schema": {
              "$ref": "#/definitions/ElasticsearchClusterInstanceSettingsOverrides"
            }
          },
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "restart_after_update",
            "in": "query",
            "description": "Whether or not to restart the instances after the overrides are applied.",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the updated settings overrides for the specified instances",
            "schema": {
              "$ref": "#/definitions/ElasticsearchClusterInstanceSettingsOverrides"
            }
          },
          "404": {
            "description": "The cluster specified at {cluster_id} could not be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/instances/{instance_ids}/settings": {
      "put": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Set settings overrides",
        "description": "Overrides settings for instances belonging to an Elasticsearch cluster.",
        "operationId": "set-es-cluster-instances-settings-overrides",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "The settings to override for the specified instances.",
            "required": false,
            "schema": {
              "$ref": "#/definitions/ElasticsearchClusterInstanceSettingsOverrides"
            }
          },
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "instance_ids",
            "in": "path",
            "description": "Optional comma-delimited list of instance identifiers of the Elasticsearch cluster, otherwise will apply to all instances",
            "required": true,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv"
          },
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "restart_after_update",
            "in": "query",
            "description": "Whether or not to restart the instances after the overrides are applied.",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the updated settings overrides for the specified instances",
            "schema": {
              "$ref": "#/definitions/ElasticsearchClusterInstanceSettingsOverrides"
            }
          },
          "404": {
            "description": "One or more of the instances specified at {instance_ids} could not be found (code: 'clusters.instances_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}": {
      "get": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Get cluster",
        "description": "Retrieves cluster information for an Elasticsearch cluster.",
        "operationId": "get-es-cluster",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "show_security",
            "in": "query",
            "description": "Whether to include the Elasticsearch 2.x security information in the response - can be large per cluster and also include credentials",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "show_metadata",
            "in": "query",
            "description": "Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "show_plans",
            "in": "query",
            "description": "Whether to include the full current and pending plan information in the response - can be large per cluster",
            "required": false,
            "type": "boolean",
            "default": true
          },
          {
            "name": "show_plan_logs",
            "in": "query",
            "description": "Whether to include with the current and pending plan information the attempt log - can be very large per cluster",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "show_plan_defaults",
            "in": "query",
            "description": "If showing plans, whether to show values that are left at their default value (less readable but more informative)",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "show_system_alerts",
            "in": "query",
            "description": "Number of system alerts (such as forced restarts due to memory limits) to be included in the response - can be large per cluster. Negative numbers or 0 will not return field.",
            "required": false,
            "type": "integer",
            "default": 0
          }
        ],
        "responses": {
          "200": {
            "description": "Returning the information for the specified Elasticsearch cluster",
            "schema": {
              "$ref": "#/definitions/ElasticsearchClusterInfo"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD"
        }
      },
      "delete": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Delete cluster",
        "description": "Deletes an Elasticsearch cluster.\nRequires that you have already successfully issued a `_shutdown` command against the cluster.",
        "operationId": "delete-es-cluster",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster has been successfully deleted",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "412": {
            "description": "The Elasticsearch cluster has not been shutdown yet (code: 'clusters.cluster_plan_state_error')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD"
        }
      }
    },
    "/clusters/kibana": {
      "get": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Get clusters",
        "description": "Retrieves cluster information for all Kibana clusters.",
        "operationId": "get-kibana-clusters",
        "parameters": [
          {
            "name": "from",
            "in": "query",
            "description": "The number of clusters to skip over",
            "required": false,
            "type": "integer",
            "default": 0
          },
          {
            "name": "size",
            "in": "query",
            "description": "The maximum number of clusters to return (set to -1 for all clusters - use with care, can result in large responses)",
            "required": false,
            "type": "integer",
            "default": 100
          },
          {
            "name": "show_metadata",
            "in": "query",
            "description": "Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "show_plans",
            "in": "query",
            "description": "Whether to include the full current and pending plan information in the response - can be large per cluster",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "show_hidden",
            "in": "query",
            "description": "Whether to include hidden clusters in the response or not",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "show_plan_defaults",
            "in": "query",
            "description": "If showing plans, whether to show values that are left at their default value (less readable but more informative)",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "200": {
            "description": "Returning the specified set of clusters from the platform",
            "schema": {
              "$ref": "#/definitions/KibanaClustersInfo"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD"
        }
      },
      "post": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Create cluster",
        "description": "Creates a Kibana cluster for a given Elasticsearch cluster.",
        "operationId": "create-kibana-cluster",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "The cluster definition",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CreateKibanaClusterRequest"
            }
          },
          {
            "name": "validate_only",
            "in": "query",
            "description": "If true, will just validate the cluster definition but will not perform the creation",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster definition was valid - no further action was requested. The return object contains an internal representation of the plan, for use in debugging",
            "schema": {
              "$ref": "#/definitions/ClusterCrudResponse"
            }
          },
          "201": {
            "description": "The cluster definition was valid and the cluster creation has started",
            "schema": {
              "$ref": "#/definitions/ClusterCrudResponse"
            }
          },
          "400": {
            "description": "The cluster definition contained errors (code: 'clusters.cluster_invalid_plan' and 'clusters.plan_feature_not_implemented')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/plan": {
      "get": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Get plan",
        "description": "Retrieves the active plan of a Kibana cluster.",
        "operationId": "get-kibana-cluster-plan",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "show_plan_defaults",
            "in": "query",
            "description": "Whether to show values that are left at their default value (less readable but more informative)",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster has a current applied plan",
            "schema": {
              "$ref": "#/definitions/KibanaClusterPlan"
            },
            "headers": {
              "x-cloud-resource-version": {
                "type": "string",
                "description": "The version of the resource - used to avoid update conflicts from multiple concurrent operations"
              },
              "x-cloud-resource-created": {
                "type": "string",
                "description": "The date-time when the resource was created (ISO format relative to UTC)"
              },
              "x-cloud-resource-last-modified": {
                "type": "string",
                "description": "The date-time when the resource was last modified (ISO format relative to UTC)"
              }
            }
          },
          "412": {
            "description": "There is not currently applied plan - eg the cluster has not finished provisioning, or the provisioning failed (code: 'clusters.cluster_plan_state_error')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD - Configuration"
        }
      },
      "post": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Update plan",
        "description": "Updates the configuration of an existing Kibana cluster.",
        "operationId": "update-kibana-cluster-plan",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "The update plan definition",
            "required": true,
            "schema": {
              "$ref": "#/definitions/KibanaClusterPlan"
            }
          },
          {
            "name": "validate_only",
            "in": "query",
            "description": "If true, will just validate the cluster definition but will not perform the update",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster definition was valid - no further action was requested. The return object contains an internal representation of the plan, for use in debugging",
            "schema": {
              "$ref": "#/definitions/ClusterCrudResponse"
            }
          },
          "202": {
            "description": "The plan definition was valid and the updated plan is in progress.",
            "schema": {
              "$ref": "#/definitions/ClusterCrudResponse"
            }
          },
          "400": {
            "description": "The cluster definition contained errors (code: 'clusters.cluster_invalid_plan' and 'clusters.plan_feature_not_implemented')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD - Configuration"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/plan/pending": {
      "get": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Get pending plan",
        "description": "Retrieves the pending plan of a Kibana cluster.",
        "operationId": "get-kibana-cluster-pending-plan",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "show_plan_defaults",
            "in": "query",
            "description": "Whether to show values that are left at their default value (less readable but more informative)",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster has a pending plan currently being applied to the cluster",
            "schema": {
              "$ref": "#/definitions/KibanaClusterPlan"
            },
            "headers": {
              "x-cloud-resource-version": {
                "type": "string",
                "description": "The version of the resource - used to avoid update conflicts from multiple concurrent operations"
              },
              "x-cloud-resource-created": {
                "type": "string",
                "description": "The date-time when the resource was created (ISO format relative to UTC)"
              },
              "x-cloud-resource-last-modified": {
                "type": "string",
                "description": "The date-time when the resource was last modified (ISO format relative to UTC)"
              }
            }
          },
          "412": {
            "description": "There is not currently applied plan - eg the cluster has not finished provisioning, or the provisioning failed (code: 'clusters.cluster_plan_state_error')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD - Configuration"
        }
      },
      "delete": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Cancel pending plan",
        "description": "Cancels the pending plan of a Kibana cluster.",
        "operationId": "cancel-kibana-cluster-pending-plan",
        "parameters": [
          {
            "name": "ignore_missing",
            "in": "query",
            "description": "If true (default false), will return successfully regardless of whether there was a pending plan or not",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The pending plan has been successfully cancelled",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "412": {
            "description": "There is not currently applied plan - eg the cluster has not finished provisioning, or the provisioning failed (code: 'clusters.cluster_plan_state_error')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD - Configuration"
        }
      }
    },
    "/clusters/kibana/{cluster_id}": {
      "get": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Get cluster",
        "description": "Retrieves cluster information for a Kibana cluster.",
        "operationId": "get-kibana-cluster",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "show_metadata",
            "in": "query",
            "description": "Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "show_plans",
            "in": "query",
            "description": "Whether to include the full current and pending plan information in the response - can be large per cluster",
            "required": false,
            "type": "boolean",
            "default": true
          },
          {
            "name": "show_plan_logs",
            "in": "query",
            "description": "Whether to include with the current and pending plan information the attempt log - can be very large per cluster",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "show_plan_defaults",
            "in": "query",
            "description": "If showing plans, whether to show values that are left at their default value (less readable but more informative)",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "200": {
            "description": "Returning the information for the specified Kibana cluster",
            "schema": {
              "$ref": "#/definitions/KibanaClusterInfo"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD"
        }
      },
      "delete": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Delete cluster",
        "description": "Deletes a Kibana cluster.\nRequires that you have already successfully issued `_shutdown` command against the cluster.",
        "operationId": "delete-kibana-cluster",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster has been successfully deleted",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "412": {
            "description": "The Kibana cluster has not been shutdown yet (code: 'clusters.cluster_plan_state_error')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/plan/activity": {
      "get": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Get plan activity",
        "description": "Retrieves the current and historical plan information for an Elasticsearch cluster.",
        "operationId": "get-es-cluster-plan-activity",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "show_plan_logs",
            "in": "query",
            "description": "Whether to include with the current/pending/historical plan information the attempt log - can be very large per cluster",
            "required": false,
            "type": "boolean",
            "default": true
          },
          {
            "name": "show_plan_defaults",
            "in": "query",
            "description": "Whether to show values that are left at their default value (less readable but more informative)",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "200": {
            "description": "Returning the plan activity for the specified Elasticsearch cluster",
            "schema": {
              "$ref": "#/definitions/ElasticsearchClusterPlansInfo"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/plan/activity": {
      "get": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Get plan activity",
        "description": "Retrieves the current and historical plan information for a Kibana cluster.",
        "operationId": "get-kibana-cluster-plan-activity",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "show_plan_logs",
            "in": "query",
            "description": "Whether to include with the current/pending/historical plan information the attempt log - can be very large per cluster",
            "required": false,
            "type": "boolean",
            "default": true
          },
          {
            "name": "show_plan_defaults",
            "in": "query",
            "description": "Whether to show values that are left at their default value (less readable but more informative)",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "200": {
            "description": "Returning the plan activity for the specified Kibana cluster",
            "schema": {
              "$ref": "#/definitions/KibanaClusterPlansInfo"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD - Configuration"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/metadata/name/{new_name}": {
      "put": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Set cluster name",
        "description": "Sets the name of an Elasticsearch cluster.",
        "operationId": "set-es-cluster-name",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "new_name",
            "in": "path",
            "description": "The new name for the cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster name was successfully changed",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/monitoring": {
      "delete": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Cancel monitoring",
        "description": "Deletes all ECE-managed monitoring destinations for an Elasticsearch cluster.",
        "operationId": "cancel-es-cluster-monitoring",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "202": {
            "description": "The destination monitoring cluster removal request was initiated",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/monitoring/{dest_cluster_id}": {
      "post": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Set monitoring",
        "description": "Overwrites or creates the ECE-managed monitoring destination for an Elasticsearch cluster.",
        "operationId": "set-es-cluster-monitoring",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "dest_cluster_id",
            "in": "path",
            "description": "The id of the cluster that will be the new monitoring destination",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "202": {
            "description": "The destination monitoring cluster creation/overwrite request was initiated",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/metadata/settings": {
      "get": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Get cluster metadata settings",
        "description": "",
        "operationId": "get-kibana-cluster-metadata-settings",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster metadata was successfully returned",
            "schema": {
              "$ref": "#/definitions/ClusterMetadataSettings"
            },
            "headers": {
              "x-cloud-resource-version": {
                "type": "string",
                "description": "The version of the resource - used to avoid update conflicts from multiple concurrent operations"
              },
              "x-cloud-resource-created": {
                "type": "string",
                "description": "The date-time when the resource was created (ISO format relative to UTC)"
              },
              "x-cloud-resource-last-modified": {
                "type": "string",
                "description": "The date-time when the resource was last modified (ISO format relative to UTC)"
              }
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD - Configuration"
        }
      },
      "patch": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Update cluster metadata settings",
        "description": "Any changes in the PATCHed object will be applied to the metadata object.  PATCHing existing fields will cause same values to be re-applied.PATCHing a value of 'null' will cause the field to be reverted to it's default value or removed if no default value exists",
        "operationId": "update-kibana-cluster-metadata-settings",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "in": "query",
            "description": "If specified then checks for conflicts against the version of the cluster metadata (returned in 'x-cloud-resource-version' of the GET request)",
            "required": false,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "The cluster settings including updated values",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ClusterMetadataSettings"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster metadata was successfully updated",
            "schema": {
              "$ref": "#/definitions/ClusterMetadataSettings"
            },
            "headers": {
              "x-cloud-resource-version": {
                "type": "string",
                "description": "The version of the resource - used to avoid update conflicts from multiple concurrent operations"
              },
              "x-cloud-resource-created": {
                "type": "string",
                "description": "The date-time when the resource was created (ISO format relative to UTC)"
              },
              "x-cloud-resource-last-modified": {
                "type": "string",
                "description": "The date-time when the resource was last modified (ISO format relative to UTC)"
              }
            }
          },
          "403": {
            "description": "The provided action was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD - Configuration"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/metadata/raw": {
      "get": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Get cluster metadata",
        "description": "Advanced use only: Retrieves the internal cluster metadata for a Kibana cluster as free-form JSON.",
        "operationId": "get-kibana-cluster-metadata-raw",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster metadata was successfully returned",
            "schema": {
              "type": "object"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD - Configuration"
        }
      },
      "post": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Set cluster metadata",
        "description": "Advanced use only: Sets the internal cluster metadata for a Kibana cluster with free-form JSON.\nMust only be used to set a modified version of the JSON returned from the get version of the metadata.",
        "operationId": "set-kibana-cluster-metadata-raw",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "in": "query",
            "description": "If specified then checks for conflicts against the version of the cluster metadata (returned in 'x-cloud-resource-version' of the GET request)",
            "required": false,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "The freeform JSON for the cluster (should always be based on the current version retrieved from the GET)",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster metadata was successfully changed (the updated JSON is returned)",
            "schema": {
              "type": "object"
            },
            "headers": {
              "x-cloud-resource-version": {
                "type": "string",
                "description": "The version of the resource - used to avoid update conflicts from multiple concurrent operations"
              },
              "x-cloud-resource-created": {
                "type": "string",
                "description": "The date-time when the resource was created (ISO format relative to UTC)"
              },
              "x-cloud-resource-last-modified": {
                "type": "string",
                "description": "The date-time when the resource was last modified (ISO format relative to UTC)"
              }
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD - Configuration"
        }
      }
    },
    "/clusters/kibana/{cluster_id}/metadata/name/{new_name}": {
      "put": {
        "tags": [
          "ClustersKibana"
        ],
        "summary": "Set cluster name",
        "description": "Sets the name of a Kibana cluster.",
        "operationId": "set-kibana-cluster-name",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Kibana cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "new_name",
            "in": "path",
            "description": "The new name for the cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster name was successfully changed",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Kibana - CRUD - Configuration"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/metadata/settings": {
      "get": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Get cluster metadata settings",
        "description": "",
        "operationId": "get-es-cluster-metadata-settings",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster metadata was successfully returned",
            "schema": {
              "$ref": "#/definitions/ClusterMetadataSettings"
            },
            "headers": {
              "x-cloud-resource-version": {
                "type": "string",
                "description": "The version of the resource - used to avoid update conflicts from multiple concurrent operations"
              },
              "x-cloud-resource-created": {
                "type": "string",
                "description": "The date-time when the resource was created (ISO format relative to UTC)"
              },
              "x-cloud-resource-last-modified": {
                "type": "string",
                "description": "The date-time when the resource was last modified (ISO format relative to UTC)"
              }
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      },
      "patch": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Update cluster metadata settings",
        "description": "Any changes in the PATCHed object will be applied to the metadata settings object.  PATCHing existing fields will cause same values to be re-applied. PATCHing a value of 'null' will cause the field to be reverted to its default value or removed if no default value exists",
        "operationId": "update-es-cluster-metadata-settings",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "in": "query",
            "description": "If specified then checks for conflicts against the version of the cluster metadata (returned in 'x-cloud-resource-version' of the GET request)",
            "required": false,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "The cluster settings including updated values",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ClusterMetadataSettings"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster metadata was successfully updated",
            "schema": {
              "$ref": "#/definitions/ClusterMetadataSettings"
            },
            "headers": {
              "x-cloud-resource-version": {
                "type": "string",
                "description": "The version of the resource - used to avoid update conflicts from multiple concurrent operations"
              },
              "x-cloud-resource-created": {
                "type": "string",
                "description": "The date-time when the resource was created (ISO format relative to UTC)"
              },
              "x-cloud-resource-last-modified": {
                "type": "string",
                "description": "The date-time when the resource was last modified (ISO format relative to UTC)"
              }
            }
          },
          "403": {
            "description": "The provided action was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/metadata/raw": {
      "get": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Get cluster metadata in raw form",
        "description": "Advanced use only: Retrieves the internal cluster metadata (free-form JSON) for an Elasticsearch cluster.",
        "operationId": "get-es-cluster-metadata-raw",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster metadata was successfully returned",
            "schema": {
              "type": "object"
            },
            "headers": {
              "x-cloud-resource-version": {
                "type": "string",
                "description": "The version of the resource - used to avoid update conflicts from multiple concurrent operations"
              },
              "x-cloud-resource-created": {
                "type": "string",
                "description": "The date-time when the resource was created (ISO format relative to UTC)"
              },
              "x-cloud-resource-last-modified": {
                "type": "string",
                "description": "The date-time when the resource was last modified (ISO format relative to UTC)"
              }
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      },
      "post": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Set cluster metadata",
        "description": "Advanced use only: Sets the internal cluster metadata (free-form JSON) for an Elasticsearch cluster.\nMust only be used to set a modified version of the JSON returned from the get version of the metadata.",
        "operationId": "set-es-cluster-metadata-raw",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "in": "query",
            "description": "If specified then checks for conflicts against the version of the cluster metadata (returned in 'x-cloud-resource-version' of the GET request)",
            "required": false,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "The freeform JSON for the cluster (should always be based on the current version retrieved from the GET)",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The cluster metadata was successfully changed (the updated JSON is returned)",
            "schema": {
              "type": "object"
            },
            "headers": {
              "x-cloud-resource-version": {
                "type": "string",
                "description": "The version of the resource - used to avoid update conflicts from multiple concurrent operations"
              },
              "x-cloud-resource-created": {
                "type": "string",
                "description": "The date-time when the resource was created (ISO format relative to UTC)"
              },
              "x-cloud-resource-last-modified": {
                "type": "string",
                "description": "The date-time when the resource was last modified (ISO format relative to UTC)"
              }
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - CRUD - Configuration"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/support/_generate-logs": {
      "get": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Generate logs",
        "description": "Retrieves a log file from the logging cluster. WARNING: not currently supported in ECE, SaaS only",
        "operationId": "generate-es-cluster-logs",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          },
          {
            "name": "date",
            "in": "query",
            "description": "A date string (standard format, eg 'YYY-MM-DD[THH[:mm]]') representing the start date for the log retrieval",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The support diagnostic bundle was successfully generated.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - Support"
        }
      }
    },
    "/clusters/elasticsearch/{cluster_id}/support/_generate-diagnostics": {
      "get": {
        "tags": [
          "ClustersElasticsearch"
        ],
        "summary": "Generate diagnostics",
        "description": "Retrieves a support diagnostic bundle from the running Elasticsearch cluster.",
        "operationId": "generate-es-cluster-diagnostics",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "description": "Identifier for the Elasticsearch cluster",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The support diagnostic bundle was successfully generated.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          "404": {
            "description": "The cluster specified by {cluster_id} cannot be found (code: 'clusters.cluster_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Clusters - Elasticsearch - Support"
        }
      }
    },
    "/platform": {
      "get": {
        "tags": [
          "Platform"
        ],
        "summary": "Get platform",
        "description": "Retrieves information about the current platform.",
        "operationId": "get-platform",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Information about the current platform",
            "schema": {
              "$ref": "#/definitions/PlatformInfo"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform"
        }
      }
    },
    "/platform/configuration/security/enrollment-tokens": {
      "get": {
        "tags": [
          "PlatformConfigurationSecurity"
        ],
        "summary": "Get enrollment tokens",
        "description": "Retrieves a list of active enrollment tokens.",
        "operationId": "get-enrollment-tokens",
        "parameters": [],
        "responses": {
          "200": {
            "description": "A token has been generated that can be used to start new servers with the requested roles",
            "schema": {
              "$ref": "#/definitions/ListEnrollmentTokenReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Configuration - Security"
        }
      },
      "post": {
        "tags": [
          "PlatformConfigurationSecurity"
        ],
        "summary": "Create enrollment token",
        "description": "Creates an enrollment token.",
        "operationId": "create-enrollment-token",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Request parameters for the enrollment token",
            "required": true,
            "schema": {
              "$ref": "#/definitions/EnrollmentTokenRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A token has been generated that can be used to start new servers with the requested roles",
            "schema": {
              "$ref": "#/definitions/RequestEnrollmentTokenReply"
            }
          },
          "400": {
            "description": "The token request format was invalid, details in the error (code: 'enrollment_tokens.invalid_token_request')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "403": {
            "description": "No signing key is available to generate a token (code: 'enrollment_tokens.signing_key_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Configuration - Security"
        }
      }
    },
    "/platform/configuration/security/enrollment-tokens/{token}": {
      "delete": {
        "tags": [
          "PlatformConfigurationSecurity"
        ],
        "summary": "Delete enrollment token",
        "description": "Revokes and deletes an enrollment token.",
        "operationId": "delete-enrollment-token",
        "parameters": [
          {
            "name": "token",
            "in": "path",
            "description": "The token identifier (or token itself) to revoke",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The supplied token has been revoked and can no longer be used to start services on new servers",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "404": {
            "description": "Token not found (code: 'enrollment_tokens.invalid_token_id')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Configuration - Security"
        }
      }
    },
    "/platform/configuration/security/tls/{service_name}": {
      "get": {
        "tags": [
          "PlatformConfigurationSecurity"
        ],
        "summary": "Get TLS certificate",
        "description": "Retrieves a certificate in the TLS certificate chain.",
        "operationId": "get-tls-certificate",
        "parameters": [
          {
            "name": "service_name",
            "in": "path",
            "description": "The service certificate chain to read, one of adminconsole, proxy, ui",
            "required": true,
            "type": "string",
            "enum": [
              "adminconsole",
              "proxy",
              "ui"
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "The TLS certificate chain, with private key omitted, for the given service and whether it was user specified",
            "schema": {
              "$ref": "#/definitions/TlsPublicCertChain"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Configuration - TLS"
        }
      },
      "post": {
        "tags": [
          "PlatformConfigurationSecurity"
        ],
        "summary": "Set TLS certificate",
        "description": "Creates or updates an existing TLS certificate chain.",
        "operationId": "set-tls-certificate",
        "parameters": [
          {
            "name": "service_name",
            "in": "path",
            "description": "The service certificate chain to update, one of adminconsole, proxy, ui",
            "required": true,
            "type": "string",
            "enum": [
              "adminconsole",
              "proxy",
              "ui"
            ]
          },
          {
            "in": "body",
            "name": "chain",
            "description": "New certificate chain: the PEM encoded RSA private key, followed by the server certificate, followed by the CA certificate",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "The TLS update has been accepted for the given service and will take effect throughout the system",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Configuration - TLS"
        }
      }
    },
    "/platform/configuration/snapshots/repositories": {
      "get": {
        "tags": [
          "PlatformConfigurationSnapshots"
        ],
        "summary": "Get snapshot repositories",
        "description": "Retrieves a list of all available snapshot repository configurations. Privileged access required for configuration contents.",
        "operationId": "get-snapshot-repositories",
        "parameters": [],
        "responses": {
          "200": {
            "description": "List of snapshot repository configs",
            "schema": {
              "$ref": "#/definitions/RepositoryConfigs"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Repository - CRUD"
        }
      }
    },
    "/platform/configuration/snapshots/repositories/{repository_name}": {
      "get": {
        "tags": [
          "PlatformConfigurationSnapshots"
        ],
        "summary": "Get snapshot repository",
        "description": "Retrieve a repository configuration by name. Privileged access required for configuration contents.",
        "operationId": "get-snapshot-repository",
        "parameters": [
          {
            "name": "repository_name",
            "in": "path",
            "description": "Custom name of a snapshot repository configuration.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Retrieve snapshot repository config",
            "schema": {
              "$ref": "#/definitions/RepositoryConfig"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Repository - CRUD"
        }
      },
      "put": {
        "tags": [
          "PlatformConfigurationSnapshots"
        ],
        "summary": "Set snapshot repository",
        "description": "Creates or updates an existing snapshot repository configuration by name.",
        "operationId": "set-snapshot-repository",
        "parameters": [
          {
            "name": "version",
            "in": "query",
            "description": "If specified, checks for conflicts against the version of the repository configuration (returned in 'x-cloud-resource-version' of the GET request)",
            "required": false,
            "type": "integer"
          },
          {
            "name": "repository_name",
            "in": "path",
            "description": "Custom name of a snapshot repository configuration.",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "description": "The Elasticsearch snapshot repository configuration.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SnapshotRepositoryConfiguration"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "New snapshot repository config",
            "schema": {
              "$ref": "#/definitions/RepositoryConfig"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Repository - CRUD"
        }
      },
      "delete": {
        "tags": [
          "PlatformConfigurationSnapshots"
        ],
        "summary": "Delete snapshot repository",
        "description": "Deletes a snapshot repository configuration by name.",
        "operationId": "delete-snapshot-repository",
        "parameters": [
          {
            "name": "repository_name",
            "in": "path",
            "description": "Custom name of a snapshot repository configuration.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "201": {
            "description": "Delete snapshot repository config",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Repository - CRUD"
        }
      }
    },
    "/platform/infrastructure/allocators/{allocator_id}/settings": {
      "get": {
        "tags": [
          "PlatformInfrastructure"
        ],
        "summary": "Get allocator settings",
        "description": "Retrieves overridable settings for an allocator.",
        "operationId": "get-allocator-settings",
        "parameters": [
          {
            "name": "allocator_id",
            "in": "path",
            "description": "Identifier for the allocator",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the settings for the specified Allocator",
            "schema": {
              "$ref": "#/definitions/AllocatorSettings"
            }
          },
          "404": {
            "description": "The allocator specified by {allocator_id} cannot be found (code: 'allocators.allocator_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Allocators"
        }
      },
      "put": {
        "tags": [
          "PlatformInfrastructure"
        ],
        "summary": "Set allocator settings",
        "description": "Overwrites the entire settings for an allocator with the settings supplied, any fields not referenced here will be deleted.",
        "operationId": "set-allocator-settings",
        "parameters": [
          {
            "name": "allocator_id",
            "in": "path",
            "description": "Identifier for the allocator",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "in": "query",
            "description": "If specified, checks for conflicts against the version of the settings (returned in 'x-cloud-resource-version' of the GET request)",
            "required": false,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "The allocator settings to apply.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/AllocatorSettings"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the updated settings for the specified allocator",
            "schema": {
              "$ref": "#/definitions/AllocatorSettings"
            }
          },
          "404": {
            "description": "The allocator specified by {allocator_id} cannot be found (code: 'allocators.allocator_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Allocators"
        }
      },
      "patch": {
        "tags": [
          "PlatformInfrastructure"
        ],
        "summary": "Update allocator settings",
        "description": "Applies the provided settings as a patch - fields not referenced in this update will not be altered.",
        "operationId": "update-allocator-settings",
        "parameters": [
          {
            "name": "allocator_id",
            "in": "path",
            "description": "Identifier for the allocator",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "in": "query",
            "description": "If specified, checks for conflicts against the version of the repository configuration (returned in 'x-cloud-resource-version' of the GET request)",
            "required": false,
            "type": "integer"
          },
          {
            "in": "body",
            "name": "body",
            "description": "The allocator settings to update.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/AllocatorSettings"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the updated settings for the specified allocator",
            "schema": {
              "$ref": "#/definitions/AllocatorSettings"
            }
          },
          "404": {
            "description": "The allocator specified by {allocator_id} cannot be found (code: 'allocators.allocator_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Allocators"
        }
      }
    },
    "/platform/infrastructure/allocators/{allocator_id}/clusters/{cluster_type}/_move": {
      "post": {
        "tags": [
          "PlatformInfrastructure"
        ],
        "summary": "Move clusters by type",
        "description": "Moves clusters of a given type off an allocator.",
        "operationId": "move-clusters-by-type",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Overrides defaults for the move of each cluster",
            "required": false,
            "schema": {
              "$ref": "#/definitions/MoveClustersRequest"
            }
          },
          {
            "name": "allocator_id",
            "in": "path",
            "description": "The identifier of the allocator of which to move clusters.",
            "required": true,
            "type": "string"
          },
          {
            "name": "cluster_type",
            "in": "path",
            "description": "The type of clusters to move off the allocator (either Elasticsearch or Kibana).  If not specified, then all clusters are moved.",
            "required": true,
            "type": "string",
            "enum": [
              "elasticsearch",
              "kibana"
            ]
          },
          {
            "name": "force_update",
            "in": "query",
            "description": "If true, will cancel any pending plans and overwrite with this move plan for all clusters, else will error",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "allocator_down",
            "in": "query",
            "description": "If true all clusters on the allocator will be considered to be permanently down for the purposes of data migration logic",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "validate_only",
            "in": "query",
            "description": "If true, will validate the plan overrides and return the plan that would be applied, without performing the move.",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The move command was issued successfully, use the \"GET\" command on each /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/MoveClustersCommandResponse"
            }
          },
          "400": {
            "description": "The cluster definition contained errors (code: 'clusters.cluster_invalid_plan' and 'clusters.plan_feature_not_implemented')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "403": {
            "description": "The move command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Allocators"
        }
      }
    },
    "/platform/infrastructure/allocators/{allocator_id}/clusters/_move": {
      "post": {
        "tags": [
          "PlatformInfrastructure"
        ],
        "summary": "Move clusters",
        "description": "Moves clusters off an allocator.",
        "operationId": "move-clusters",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Overrides defaults for the move of each cluster",
            "required": false,
            "schema": {
              "$ref": "#/definitions/MoveClustersRequest"
            }
          },
          {
            "name": "allocator_id",
            "in": "path",
            "description": "The identifier of the allocator of which to move clusters.",
            "required": true,
            "type": "string"
          },
          {
            "name": "force_update",
            "in": "query",
            "description": "If true, will cancel any pending plans and overwrite with this move plan for all clusters, else will error",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "allocator_down",
            "in": "query",
            "description": "Tells the infrastructure that all instances on the allocator should be considered as permanently down when deciding how to migrate data to new nodes. If left blank then the system will auto-decide (currently: will treat the allocator as up)",
            "required": false,
            "type": "boolean",
            "default": false
          },
          {
            "name": "validate_only",
            "in": "query",
            "description": "If true, will validate the plan overrides and return the plan that would be applied, without performing the move.",
            "required": false,
            "type": "boolean",
            "default": false
          }
        ],
        "responses": {
          "202": {
            "description": "The move command was issued successfully, use the \"GET\" command on each /{cluster_id} resource to monitor progress",
            "schema": {
              "$ref": "#/definitions/MoveClustersCommandResponse"
            }
          },
          "400": {
            "description": "The cluster definition contained errors (code: 'clusters.cluster_invalid_plan' and 'clusters.plan_feature_not_implemented')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "403": {
            "description": "The move command was prohibited for the given cluster.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Allocators"
        }
      }
    },
    "/platform/infrastructure/allocators/{allocator_id}/metadata": {
      "get": {
        "tags": [
          "PlatformInfrastructure"
        ],
        "summary": "Get allocator metadata",
        "description": "Retrieves the metadata for a given allocator.",
        "operationId": "get-allocator-metadata",
        "parameters": [
          {
            "name": "allocator_id",
            "in": "path",
            "description": "The identifier for the allocator.",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The allocator metadata was successfully returned.",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AllocatorMetadataItem"
              }
            }
          },
          "404": {
            "description": "The allocator specified by {allocator_id} cannot be found (code: 'allocators.allocator_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Allocators"
        }
      },
      "put": {
        "tags": [
          "PlatformInfrastructure"
        ],
        "summary": "Set allocator metadata",
        "description": "Sets the metadata for a given allocator.",
        "operationId": "set-allocator-metadata",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "The metadata to update the allocator with.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/AllocatorMetadataItems"
            }
          },
          {
            "name": "allocator_id",
            "in": "path",
            "description": "The identifier for the allocator.",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "in": "query",
            "description": "If specified, checks for conflicts against the version of the metadata (returned in 'x-cloud-resource-version' of the GET request)",
            "required": false,
            "type": "integer"
          }
        ],
        "responses": {
          "202": {
            "description": "The allocator metadata was successfully changed (the updated JSON is returned)",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AllocatorMetadataItem"
              }
            }
          },
          "404": {
            "description": "The allocator specified by {allocator_id} cannot be found (code: 'allocators.allocator_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Allocators"
        }
      }
    },
    "/platform/infrastructure/allocators/{allocator_id}/metadata/{key}": {
      "put": {
        "tags": [
          "PlatformInfrastructure"
        ],
        "summary": "Set allocator metadata item",
        "description": "Adds or updates a single item to a given allocators metadata.",
        "operationId": "set-allocator-metadata-item",
        "parameters": [
          {
            "name": "allocator_id",
            "in": "path",
            "description": "The identifier for the allocator.",
            "required": true,
            "type": "string"
          },
          {
            "name": "key",
            "in": "path",
            "description": "The key of the metadata item to add or update.",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "description": "The value of the metadata item to add or update.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/AllocatorMetadataItemValue"
            }
          },
          {
            "name": "version",
            "in": "query",
            "description": "If specified, checks for conflicts against the version of the metadata (returned in 'x-cloud-resource-version' of the GET request)",
            "required": false,
            "type": "integer"
          }
        ],
        "responses": {
          "202": {
            "description": "The allocator metadata was successfully changed (the updated JSON is returned)",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AllocatorMetadataItem"
              }
            }
          },
          "404": {
            "description": "The allocator specified by {allocator_id} cannot be found (code: 'allocators.allocator_not_found') or the metadata item specified by {key} cannot be found (code: 'allocators.metadata_item_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Allocators"
        }
      },
      "delete": {
        "tags": [
          "PlatformInfrastructure"
        ],
        "summary": "Delete allocator metadata item",
        "description": "Removes a single item from a given allocators metadata.",
        "operationId": "delete-allocator-metadata-item",
        "parameters": [
          {
            "name": "allocator_id",
            "in": "path",
            "description": "The identifier for the allocator.",
            "required": true,
            "type": "string"
          },
          {
            "name": "key",
            "in": "path",
            "description": "The key of the metadata item to remove.",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "in": "query",
            "description": "If specified, checks for conflicts against the version of the metadata (returned in 'x-cloud-resource-version' of the GET request)",
            "required": false,
            "type": "integer"
          }
        ],
        "responses": {
          "202": {
            "description": "The allocator metadata was successfully changed (the updated JSON is returned)",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AllocatorMetadataItem"
              }
            }
          },
          "404": {
            "description": "The allocator specified by {allocator_id} cannot be found (code: 'allocators.allocator_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Allocators"
        }
      }
    },
    "/platform/infrastructure/allocators": {
      "get": {
        "tags": [
          "PlatformInfrastructure"
        ],
        "summary": "Get allocators",
        "description": "Retrieves an overview of all allocators in an ECE installation.",
        "operationId": "get-allocators",
        "parameters": [
          {
            "name": "q",
            "in": "query",
            "description": "An optional query to filter allocators by. Maps to an Elasticsearch query_string query.",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "An overview of all allocators.",
            "schema": {
              "$ref": "#/definitions/AllocatorOverview"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Allocators"
        }
      }
    },
    "/platform/infrastructure/allocators/{allocator_id}": {
      "get": {
        "tags": [
          "PlatformInfrastructure"
        ],
        "summary": "Get allocator",
        "description": "Retrieves an allocator by id.",
        "operationId": "get-allocator",
        "parameters": [
          {
            "name": "allocator_id",
            "in": "path",
            "description": "Identifier for the allocator",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The information for the allocator specified by {allocator_id}.",
            "schema": {
              "$ref": "#/definitions/AllocatorInfo"
            }
          },
          "404": {
            "description": "The allocator specified by {allocator_id} cannot be found (code: 'allocators.allocator_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Allocators"
        }
      },
      "delete": {
        "tags": [
          "PlatformInfrastructure"
        ],
        "summary": "Delete allocator",
        "description": "Deletes an allocator by id.",
        "operationId": "delete-allocator",
        "parameters": [
          {
            "name": "allocator_id",
            "in": "path",
            "description": "Identifier for the allocator",
            "required": true,
            "type": "string"
          },
          {
            "name": "remove_instances",
            "in": "query",
            "description": "Whether or not to also remove the instances on the allocator that's being deleted.",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "The allocator specified by {allocator_id} was successfully deleted.",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "404": {
            "description": "The allocator specified by {allocator_id} cannot be found (code: 'allocators.allocator_not_found')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "400": {
            "description": "The allocator specified by {allocator_id} could not be deleted, probably because it's connected.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Allocators"
        }
      }
    },
    "/platform/infrastructure/allocators/_search": {
      "post": {
        "tags": [
          "PlatformInfrastructure"
        ],
        "summary": "Search allocators",
        "description": "Retrieves allocators in an ECE installation that match a given query.",
        "operationId": "search-allocators",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "The optional search request to execute. If not supplied then all allocators are matched.",
            "required": false,
            "schema": {
              "$ref": "#/definitions/SearchRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "An overview of allocators that matched the given search query.",
            "schema": {
              "$ref": "#/definitions/AllocatorOverview"
            }
          },
          "400": {
            "description": "The search request failed.",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Platform - Allocators"
        }
      }
    },
    "/stack/versions": {
      "get": {
        "tags": [
          "Stack"
        ],
        "summary": "Get all available Elastic Stack versions",
        "description": "By default it returns only available versions. Use parameter `show_deleted` to get all versions",
        "operationId": "get-version-stacks",
        "parameters": [
          {
            "name": "show_deleted",
            "in": "query",
            "description": "Whether to show deleted stack versions or not",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "List of all available stack configurations with template version and structure",
            "schema": {
              "$ref": "#/definitions/StackVersionConfigs"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Stack - CRUD"
        }
      },
      "post": {
        "tags": [
          "Stack"
        ],
        "summary": "Submit Elastic Stack packs",
        "description": "Adds a new or updates existing Elastic Stack version and its template.\nBesides `multipart/form-data` requests, the endpoint supports `application/zip` and `application/octet-stream` requests with a binary body. Maximum size of the payload is 1Mb.\nIf the archive contains a stack configuration that is already available through the API, then the existing configuration and its template will be overwritten.",
        "operationId": "update-stack-packs",
        "consumes": [
          "multipart/form-data"
        ],
        "parameters": [
          {
            "name": "file",
            "in": "formData",
            "description": "Zip file that contains one or multiple stack configurations",
            "required": true,
            "type": "file"
          }
        ],
        "responses": {
          "200": {
            "description": "The Stack Pack was processed successfully",
            "schema": {
              "$ref": "#/definitions/StackVersionArchiveProcessingResult"
            }
          },
          "400": {
            "description": "Bad archive or some unexpected error occurred",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Stack - CRUD"
        }
      }
    },
    "/stack/versions/{version}": {
      "get": {
        "tags": [
          "Stack"
        ],
        "summary": "Get an Elastic Stack version",
        "description": "Retrieves a single Elastic Stack version with template.",
        "operationId": "get-version-stack",
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "description": "An Elastic Stack version",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The Elastic Stack version was found",
            "schema": {
              "$ref": "#/definitions/StackVersionConfig"
            }
          },
          "404": {
            "description": "The Elastic Stack version was not found",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Stack - CRUD"
        }
      },
      "put": {
        "tags": [
          "Stack"
        ],
        "summary": "Update an Elastic Stack version",
        "description": "Updates the configuration of an existing Elastic Stack version.",
        "operationId": "update-version-stack",
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "description": "An Elastic Stack version",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "stackConfig",
            "description": "Elastic Stack configuration object",
            "required": true,
            "schema": {
              "$ref": "#/definitions/StackVersionConfigPost"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The Elastic Stack version was updated successfully",
            "schema": {
              "$ref": "#/definitions/StackVersionConfig"
            }
          },
          "404": {
            "description": "The Elastic Stack version was not found",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Stack - CRUD"
        }
      },
      "delete": {
        "tags": [
          "Stack"
        ],
        "summary": "Mark an Elastic Stack version for deletion",
        "description": "Sets a flag 'deleted' that effectively only removes the Elastic Stack Version from the list of available versions. The version can be restored later by sending an update request for the version (See PUT request)",
        "operationId": "delete-version-stack",
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "description": "An Elastic Stack version",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The Elastic Stack version was marked for deletion successfully",
            "schema": {
              "$ref": "#/definitions/EmptyResponse"
            }
          },
          "404": {
            "description": "The Elastic Stack version was not found",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          },
          "449": {
            "description": "When running as an administrator (other than root), sudo is required (code: 'root.needs_sudo')",
            "schema": {
              "$ref": "#/definitions/BasicFailedReply"
            }
          }
        },
        "security": [
          {
            "basicAuth": []
          },
          {
            "apiKey": []
          }
        ],
        "x-doc": {
          "tag": "Stack - CRUD"
        }
      }
    }
  },
  "securityDefinitions": {
    "basicAuth": {
      "type": "basic"
    },
    "apiKey": {
      "type": "apiKey",
      "name": "Authorization",
      "in": "header"
    }
  },
  "definitions": {
    "AllocatorMoveRequest": {
      "type": "object",
      "required": [
        "from"
      ],
      "properties": {
        "from": {
          "type": "string",
          "description": "The allocator id off which all instances in the cluster should be moved"
        },
        "to": {
          "type": "array",
          "description": "An optional list of allocator ids to which the instance(s) should be moved. If not specified then any available allocator can be used (including the current one if it is healthy)",
          "items": {
            "type": "string"
          }
        },
        "allocator_down": {
          "type": "boolean",
          "description": "Tells the infrastructure that all instances on the allocator should be considered as permanently down when deciding how to migrate data to new nodes. If left blank then the system will auto-decide (currently: will treat the allocator as up)"
        }
      },
      "description": "Requests that any instances on the specified allocators be moved to (optionally specified) different allocators as part of the upgrade plan"
    },
    "ClusterCommandResponse": {
      "type": "object",
      "properties": {
        "calculated_elasticsearch_plan": {
          "description": "If validating the command only, then the calculated Elasticsearch plan that would be applied.",
          "$ref": "#/definitions/ElasticsearchPlanControlConfiguration"
        },
        "calculated_kibana_plan": {
          "description": "If validating the command only, then the calculated Kibana plan that would be applied.",
          "$ref": "#/definitions/KibanaPlanControlConfiguration"
        }
      },
      "description": "The response to an Elasticsearch or Kibana cluster command."
    },
    "ElasticsearchPlanControlConfiguration": {
      "type": "object",
      "properties": {
        "timeout": {
          "type": "integer",
          "format": "int64",
          "description": "The total timeout in seconds after which the plan is cancelled even if it is not complete. Defaults to 4x the max memory capacity per node (in MB). NOTES: (eg a 3 zone cluster with 2 nodes of 2048 each would have a timeout of 4*2048=8192 seconds)"
        },
        "calm_wait_time": {
          "type": "integer",
          "format": "int64",
          "description": "This timeout determines how long to give a cluster after it responds to API calls before performing actual operations on it. It defaults to 5s"
        },
        "move_instances": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/InstanceMoveRequest"
          }
        },
        "move_allocators": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AllocatorMoveRequest"
          }
        },
        "reallocate_instances": {
          "type": "boolean",
          "description": "If true (default: false) does not allow re-using any existing instances currently in the cluster, ie even unchanged instances will be re-created"
        },
        "preferred_allocators": {
          "type": "array",
          "description": "List of allocators on which instances are placed if possible (if not possible/not specified then any available allocator with space is used)",
          "items": {
            "type": "string"
          }
        },
        "skip_snapshot": {
          "type": "boolean",
          "description": "If true (default: false), does not take (or require) a successful snapshot to be taken before performing any potentially destructive changes to this cluster"
        },
        "max_snapshot_attempts": {
          "type": "integer",
          "format": "int32",
          "description": "If taking a snapshot (ie unless 'skip_snapshots': true) then will retry on failure at most this number of times (default: 5)"
        },
        "extended_maintenance": {
          "type": "boolean",
          "description": "If true (default false), does not clear the maintenance flag (which prevents its API from being accessed except by the constructor) on new instances added until after a snapshot has been restored, otherwise, the maintenance flag is cleared once the new instances successfully join the new cluster"
        },
        "cluster_reboot": {
          "type": "string",
          "description": "Set to 'forced' to force a reboot as part of the upgrade plan. NOTES: (ie taking an existing plan and leaving it alone except for setting 'transient.plan_configuration.cluster_reboot': 'forced' will reboot the cluster)",
          "enum": [
            "forced"
          ]
        },
        "override_failsafe": {
          "type": "boolean",
          "description": "If false (the default) then the plan will fail out if it believes the requested sequence of operations can result in data loss - this flag will override some of these restraints"
        },
        "skip_data_migration": {
          "type": "boolean",
          "description": "If true (default: false) then the plan will not wait for data to be migrated from old instances to new instances before continuing the plan (potentially deleting the old instances and losing data)"
        },
        "skip_upgrade_checker": {
          "type": "boolean",
          "description": "If false, the cluster is checked for issues that should be resolved before migration (eg contains old Lucene segments), if true this is bypassed"
        },
        "skip_post_upgrade_steps": {
          "type": "boolean",
          "description": "If false (the default), the cluster will run (currently) 2.x->5.x operations for any plan change ending with a 5.x cluster (eg apply a cluster license, ensure Monitoring is configured)"
        }
      },
      "description": "Fine grained control over various timeout and fallback parameters"
    },
    "InstanceMoveRequest": {
      "type": "object",
      "required": [
        "from"
      ],
      "properties": {
        "from": {
          "type": "string",
          "description": "The instance id that is going to be moved"
        },
        "to": {
          "type": "array",
          "description": "An optional list of allocator ids to which the instance should be moved. If not specified then any available allocator can be used (including the current one if it is healthy)",
          "items": {
            "type": "string"
          }
        },
        "instance_down": {
          "type": "boolean",
          "description": "Tells the infrastructure that the instance should be considered as permanently down when deciding how to migrate data to new nodes. If left blank then the system will automatically decide (currently: will treat the instances as up)"
        }
      },
      "description": "Requests that the specified instances be moved to (optionally specified) different allocators as part of the upgrade plan"
    },
    "KibanaPlanControlConfiguration": {
      "type": "object",
      "properties": {
        "timeout": {
          "type": "integer",
          "format": "int64",
          "description": "The total timeout in seconds after which the plan is cancelled even if it is not complete. Defaults to 4x the max memory capacity per node (in MB)"
        },
        "calm_wait_time": {
          "type": "integer",
          "format": "int64",
          "description": "This timeout determines how long to give a cluster after it responds to API calls before performing actual operations on it. It defaults to 5s"
        },
        "move_instances": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/InstanceMoveRequest"
          }
        },
        "move_allocators": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AllocatorMoveRequest"
          }
        },
        "reallocate_instances": {
          "type": "boolean",
          "description": "If true (default: false) does not allow re-using any existing instances currently in the cluster, ie even unchanged instances will be re-created"
        },
        "preferred_allocators": {
          "type": "array",
          "description": "List of allocators on which instances are placed if possible (if not possible/not specified then any available allocator with space is used)",
          "items": {
            "type": "string"
          }
        },
        "extended_maintenance": {
          "type": "boolean",
          "description": "If true (default false), does not clear the maintenance flag (which prevents its API from being accessed except by the constructor) on new instances added until after a snapshot has been restored, otherwise, the maintenance flag is cleared once the new instances successfully join the new cluster"
        },
        "cluster_reboot": {
          "type": "string",
          "description": "Set to 'forced' to force a reboot as part of the upgrade plan",
          "enum": [
            "forced"
          ]
        }
      }
    },
    "BasicFailedReply": {
      "type": "object",
      "required": [
        "errors"
      ],
      "properties": {
        "errors": {
          "type": "array",
          "description": "A list of errors that occurred in the failing request",
          "items": {
            "$ref": "#/definitions/BasicFailedReplyElement"
          }
        }
      }
    },
    "BasicFailedReplyElement": {
      "type": "object",
      "required": [
        "code",
        "message"
      ],
      "properties": {
        "code": {
          "type": "string",
          "description": "A structured code representing the error type that occurred"
        },
        "message": {
          "type": "string",
          "description": "A human readable message describing the error that occurred"
        },
        "fields": {
          "type": "array",
          "description": "If the error can be tied to a specific field or fields in the user request, this lists those fields",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "EmptyResponse": {
      "type": "object"
    },
    "GrowShrinkStrategyConfig": {
      "type": "object",
      "description": "A simple strategy that creates new instances with the new plan, migrates data across from the old instances, and then shuts down the old instances - it is safer than 'rolling' and ensures single node availability during a plan change, but can be a lot slower on larger clusters"
    },
    "JSON": {
      "type": "object"
    },
    "PlanStrategy": {
      "type": "object",
      "properties": {
        "rolling": {
          "$ref": "#/definitions/RollingStrategyConfig"
        },
        "grow_and_shrink": {
          "$ref": "#/definitions/GrowShrinkStrategyConfig"
        },
        "rolling_grow_and_shrink": {
          "$ref": "#/definitions/RollingGrowShrinkStrategyConfig"
        }
      },
      "description": "Describes various options that affect how we will perform a plan change. Only one of these can be specified at a time. The default is to let the system decide on the best method (currently it will always be 'grow_and_shrink' unless manually specified)"
    },
    "RestoreSnapshotApiConfiguration": {
      "type": "object",
      "properties": {
        "indices": {
          "type": "array",
          "description": "The list of indices to restore (supports +ve and -ve selection and wildcarding - see the default Elasticsearch index format documentation)",
          "items": {
            "type": "string"
          }
        },
        "raw_settings": {
          "type": "object",
          "description": "This JSON object (merged with the 'indices' field (if present) is passed untouched into the restore command - see the Elasticsearch '_snapshot' documentation for more details on supported formats"
        }
      },
      "description": "Provides fine grained control over the restore command (in particular which indices to restore)"
    },
    "RestoreSnapshotConfiguration": {
      "type": "object",
      "required": [
        "snapshot_name"
      ],
      "properties": {
        "repository_name": {
          "type": "string",
          "description": "If specified, contains the name of the snapshot repository - else will default to the Elastic Cloud system repo ('found-snapshots')"
        },
        "snapshot_name": {
          "type": "string",
          "description": "The name of the snapshot to restore. Use '\\_\\_latest_success\\_\\_' to get the most recent snapshot from the specified repository"
        },
        "repository_config": {
          "$ref": "#/definitions/RestoreSnapshotRepoConfiguration"
        },
        "restore_payload": {
          "$ref": "#/definitions/RestoreSnapshotApiConfiguration"
        }
      },
      "description": "Allows for a snapshot of existing data to be applied from a local or remote repository once the new/upgraded cluster is up"
    },
    "RestoreSnapshotRepoConfiguration": {
      "type": "object",
      "properties": {
        "raw_settings": {
          "type": "object",
          "description": "The remote snapshot settings raw JSON - see the Elasticsearch '_snapshot' documentation for more details on supported formats"
        }
      },
      "description": "Configures the location of a remote repository (defaults to the Elastic Cloud system repo)"
    },
    "RollingGrowShrinkStrategyConfig": {
      "type": "object",
      "description": "A simple strategy that creates new instances with the new plan one by one, migrates data from one node that needs to be removed and proceeds to the next node to add/remove. It allows minimizing the amount of spare capacity needed."
    },
    "RollingStrategyConfig": {
      "type": "object",
      "properties": {
        "group_by": {
          "type": "string",
          "description": "Specifies the grouping attribute to use when rolling several instances. Instances that share the same value for the provided attribute key are rolled together as a unit. Examples that make sense to use are '\\_\\_all\\_\\_' (roll all instances as a single unit), 'logical_zone_name' (roll instances by zone), '\\_\\_name\\_\\_' (roll one instance at a time, the default if not specified). Note that '\\_\\_all\\_\\_' is required when performing a major version upgrade"
        },
        "allow_inline_resize": {
          "type": "boolean",
          "description": "Whether we allow changing the capacity of instances (default false). This is currently implemented by stopping, re-creating then starting the affected instance on its associated allocator when performing the changes. NOTES: This requires a round-trip through the allocation infrastructure of the active constructor, as it has to reserve the target capacity without over-committing"
        },
        "skip_synced_flush": {
          "type": "boolean",
          "description": "Whether to skip attempting to do a synced flush on the filesystem of the container (default: false), which is less safe but may be required if the container is unhealthy"
        }
      },
      "description": "Allows for performing many configuration changes in-line in a rolling manner, mutating existing containers.It is the fastest way of updating a plan, but may fail for more complex plan changes (eg topology changes) and is less safe for eg configuration changes that can leave a cluster in a non-running state. Note that rolling (with 'group_by' set to '\\_\\_all\\_\\_') is required when performing a major version upgrade"
    },
    "TransientElasticsearchPlanConfiguration": {
      "type": "object",
      "properties": {
        "strategy": {
          "$ref": "#/definitions/PlanStrategy"
        },
        "plan_configuration": {
          "$ref": "#/definitions/ElasticsearchPlanControlConfiguration"
        },
        "restore_snapshot": {
          "$ref": "#/definitions/RestoreSnapshotConfiguration"
        },
        "cluster_settings_json": {
          "type": "object",
          "description": "If specified, contains transient settings to be applied to an Elasticsearch cluster during changes, with the following default values applied.\n- indices.store.throttle.max_bytes_per_sec: 150Mb\n- indices.recovery.max_bytes_per_sec: 150Mb\n- cluster.routing.allocation.cluster_concurrent_rebalance: 10\n- cluster.routing.allocation.node_initial_primaries_recoveries: 8\nThese can be overridden by specifying them in the map. Additional settings can also be set. Settings will be cleared after the plan has finished.\nIf not specified, no settings will be applied."
        }
      },
      "description": "Defines configuration parameters that control how the plan (ie consisting of the cluster topology and Elasticsearch settings) is applied"
    },
    "TransientKibanaPlanConfiguration": {
      "type": "object",
      "properties": {
        "strategy": {
          "$ref": "#/definitions/PlanStrategy"
        },
        "plan_configuration": {
          "$ref": "#/definitions/KibanaPlanControlConfiguration"
        }
      },
      "description": "Defines configuration parameters that control how the plan (ie consisting of the cluster topology and Kibana settings) is applied"
    },
    "ClusterCredentials": {
      "type": "object",
      "properties": {
        "username": {
          "type": "string",
          "description": "The username of the newly created cluster"
        },
        "password": {
          "type": "string",
          "description": "The password of the newly created cluster"
        }
      },
      "description": "The username/password of the newly created cluster (returned from Elasticsearch cluster creates)"
    },
    "ClusterCrudResponse": {
      "type": "object",
      "properties": {
        "elasticsearch_cluster_id": {
          "type": "string",
          "description": "For an operation creating or updating an Elasticsearch cluster, the Id of that cluster"
        },
        "kibana_cluster_id": {
          "type": "string",
          "description": "For an operation creating or updating a Kibana cluster, the Id of that cluster"
        },
        "credentials": {
          "$ref": "#/definitions/ClusterCredentials"
        },
        "diagnostics": {
          "type": "object",
          "description": "If the endpoint is called with URL param 'validate_only=true', then this contains advanced debug info (the internal plan representation)"
        }
      },
      "description": "The response to an Elasticsearch or Kibana CRUD (create/update-plan) request"
    },
    "CreateElasticsearchClusterRequest": {
      "type": "object",
      "required": [
        "plan"
      ],
      "properties": {
        "cluster_name": {
          "type": "string",
          "description": "The human readable name for the cluster (defaults to the generated cluster id if not specified)"
        },
        "plan": {
          "$ref": "#/definitions/ElasticsearchClusterPlan"
        },
        "settings": {
          "$ref": "#/definitions/ElasticsearchClusterSettings"
        },
        "kibana": {
          "$ref": "#/definitions/CreateKibanaInCreateElasticsearchRequest"
        }
      },
      "description": "The body of a request to create a new cluster"
    },
    "CreateKibanaInCreateElasticsearchRequest": {
      "type": "object",
      "required": [
        "plan"
      ],
      "properties": {
        "cluster_name": {
          "type": "string",
          "description": "The human readable name for the Kibana cluster (default: takes the name of its Elasticsearch cluster)"
        },
        "plan": {
          "$ref": "#/definitions/KibanaClusterPlan"
        }
      },
      "description": "The body of a request to create a new Kibana cluster as part of an Elasticearch cluster creation request"
    },
    "ElasticsearchClusterPlan": {
      "type": "object",
      "required": [
        "cluster_topology",
        "elasticsearch"
      ],
      "properties": {
        "zone_count": {
          "type": "integer",
          "format": "int32",
          "description": "The default number of zones in which data nodes will be placed, if not specified in the per topology settings"
        },
        "tiebreaker_override": {
          "type": "boolean",
          "description": "Whether to add a tiebreaker node in an unused zone (defaults to auto-decide based on topology). If master nodes are specified then this cannot be left blank, you must explictly decide true or false."
        },
        "tiebreaker_topology": {
          "$ref": "#/definitions/TiebreakerTopologyElement"
        },
        "cluster_topology": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ElasticsearchClusterTopologyElement"
          }
        },
        "elasticsearch": {
          "$ref": "#/definitions/ElasticsearchConfiguration"
        },
        "transient": {
          "$ref": "#/definitions/TransientElasticsearchPlanConfiguration"
        }
      },
      "description": "The plan that defines the cluster"
    },
    "ElasticsearchClusterSettings": {
      "type": "object",
      "properties": {
        "snapshot": {
          "$ref": "#/definitions/ManagedSnapshotSettings"
        },
        "monitoring": {
          "$ref": "#/definitions/ManagedMonitoringSettings"
        }
      },
      "description": "Settings for controlling ECE functionality for an Elasticsearch cluster"
    },
    "ElasticsearchClusterTopologyElement": {
      "type": "object",
      "required": [
        "memory_per_node",
        "node_count_per_zone"
      ],
      "properties": {
        "node_type": {
          "$ref": "#/definitions/ElasticsearchNodeType"
        },
        "memory_per_node": {
          "type": "integer",
          "format": "int32",
          "description": "The memory capacity in MB for each node of this type built in each zone. NOTES: (Only powers of 2 starting with 1024 are supported. Will fail to allocate if too much memory is requested - use 'node_count_per_zone' in that case to split the cluster up within a zone)"
        },
        "node_count_per_zone": {
          "type": "integer",
          "format": "int32",
          "description": "The number of nodes of this type that are allocated within each zone. NOTES: (ie total capacity per zone = 'node_count_per_zone' * 'memory_per_node' in MB). Cannot be set for tiebreaker topologies. For dedicated master nodes, must be 1 if an entry exists"
        },
        "zone_count": {
          "type": "integer",
          "format": "int32",
          "description": "The default number of zones in which data nodes will be placed"
        },
        "elasticsearch": {
          "$ref": "#/definitions/ElasticsearchConfiguration"
        },
        "allocator_filter": {
          "type": "object",
          "description": "DEPRECATED: Controls the allocation strategy of this node type using a simplified version of the Elasticsearch filter DSL (together with 'node_configuration')"
        },
        "node_configuration": {
          "type": "string",
          "description": "Controls the allocation strategy of this node type by pointing to the names of pre-registered allocator settings. Unless otherwise specified for this deployment, only 'default' is supported (equivalent to omitting)."
        }
      },
      "description": "Defines the topology of the Elasticsearch nodes (eg number/capacity/types of nodes, and where they can be allocated)"
    },
    "ElasticsearchConfiguration": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "description": "The version of the Elasticsearch cluster (must be one of the ECE supported versions). Currently cannot be different across the topology (and is generally specified in the globals)"
        },
        "docker_image": {
          "type": "string",
          "description": "A docker URI that allows overriding of the default docker image specified for this version"
        },
        "system_settings": {
          "$ref": "#/definitions/ElasticsearchSystemSettings"
        },
        "user_settings_json": {
          "type": "object",
          "description": "An arbitrary JSON object allowing cluster owners to set their parameters (only one of this and 'user_settings_yaml' is allowed), provided they are on the whitelist ('user_settings_whitelist') and not on the blacklist ('user_settings_blacklist'). NOTES: (This field together with 'user_settings_override*' and 'system_settings' defines the total set of Elasticsearch settings)"
        },
        "user_settings_yaml": {
          "type": "string",
          "description": "An arbitrary YAML object allowing cluster owners to set their parameters (only one of this and 'user_settings_json' is allowed), provided they are on the whitelist ('user_settings_whitelist') and not on the blacklist ('user_settings_blacklist'). NOTES: (This field together with 'user_settings_override*' and 'system_settings' defines the total set of Elasticsearch settings)"
        },
        "user_settings_override_json": {
          "type": "object",
          "description": "An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_yaml' is allowed), ie in addition to the documented 'system_settings'. NOTES: (This field together with 'system_settings' and 'user_settings*' defines the total set of Elasticsearch settings)"
        },
        "user_settings_override_yaml": {
          "type": "string",
          "description": "An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_json' is allowed), ie in addition to the documented 'system_settings'. NOTES: (This field together with 'system_settings' and 'user_settings*' defines the total set of Elasticsearch settings)"
        },
        "enabled_built_in_plugins": {
          "type": "array",
          "description": "A list of plugin names from the Elastic-supported subset that are bundled with the version images. NOTES: (Users should consult the Elastic stack objects to see what plugins are available, this is currently only available from the UI)",
          "items": {
            "type": "string"
          }
        },
        "user_plugins": {
          "type": "array",
          "description": "A list of admin-uploaded plugin objects that are available for this user. NOTES: Not yet supported in ECE, SaaS only",
          "items": {
            "$ref": "#/definitions/ElasticsearchUserPlugin"
          }
        },
        "user_bundles": {
          "type": "array",
          "description": "A list of admin-uploaded bundle objects (eg scripts, synonym files) that are available for this user. NOTES: Not yet supported in ECE, SaaS only",
          "items": {
            "$ref": "#/definitions/ElasticsearchUserBundle"
          }
        }
      },
      "description": "Defines the Elasticsearch cluster settings. (If specified at the top level provides a field-by-field default; at the topology level provides the overrides)"
    },
    "ElasticsearchHttpUserSettings": {
      "type": "object",
      "properties": {
        "compression": {
          "type": "boolean",
          "description": "Controls whether HTTP API responses are compressed (default: true). NOTES: (Corresponds to the parameter 'http.compression')"
        },
        "cors_enabled": {
          "type": "boolean",
          "description": "Enables or disables (default is disabled) CORS support - see CORS documentation. NOTES: (Corresponds to the parameter 'http.cors.enabled')"
        },
        "cors_allow_origin": {
          "type": "string",
          "description": "Which origins to allow. Defaults to no origins allowed. If you prepend and append a / to the value, this will be treated as a regular expression, allowing you to support HTTP and HTTPs. for example using /https?:\\/\\/localhost(:[0-9]+)?/ would return the request header appropriately in both cases. * is a valid value but is considered a security risk as your elasticsearch instance is open to cross origin requests from anywhere. NOTES: (Corresponds to the parameter 'http.cors.allow-origin')"
        },
        "cors_max_age": {
          "type": "integer",
          "format": "int32",
          "description": "Browsers send a \"preflight\" OPTIONS-request to determine CORS settings. max-age defines how long the result should be cached for. Defaults to 1728000 (20 days). NOTES: (Corresponds to the parameter 'http.cors.max-age')"
        },
        "cors_allow_methods": {
          "type": "string",
          "description": "Which methods to allow. Defaults to \"OPTIONS, HEAD, GET, POST, PUT, DELETE\". NOTES: (The string is inserted into the value for header 'http.cors.allow-methods')"
        },
        "cors_allow_headers": {
          "type": "string",
          "description": "Which headers to allow. Defaults to \"X-Requested-With, Content-Type, Content-Length\". NOTES: (The string is inserted into the value for header 'http.cors.allow-headers')"
        },
        "cors_allow_credentials": {
          "type": "boolean",
          "description": "Whether the Access-Control-Allow-Credentials header should be returned. Note: This header is only returned, when the setting is set to true. Defaults to false. NOTES: (Corresponds to the parameter 'http.cors.allow-credentials')"
        }
      },
      "description": "Controls the HTTP API that the Elasticsearch cluster exposes"
    },
    "ElasticsearchNodeType": {
      "type": "object",
      "properties": {
        "master": {
          "type": "boolean",
          "description": "Defines whether this node can be elected master (default: true)"
        },
        "data": {
          "type": "boolean",
          "description": "Defines whether this node can hold data (default: true)"
        },
        "ingest": {
          "type": "boolean",
          "description": "Defines whether this node can run an ingest pipeline (default: true)"
        }
      },
      "description": "Controls the combinations of different Elasticsearch node types (default: can be master, can hold data, can run ingest pipelines). (Cannot be set for tiebreaker topologies)"
    },
    "ElasticsearchScriptTypeSettings": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "If enabled (default: true) then scripts are enabled, either for sandboxing languages (by default), or for all installed languages if 'sandbox_mode' is disabled (or for 6.x). NOTES: (Corresponds to the parameter 'script.file|stored/indexed|inline')"
        },
        "sandbox_mode": {
          "type": "boolean",
          "description": "If enabled (default: true) and this script type is enabled, then only the sandbox languages are allowed. By default the sandbox languages are painless, expressions and mustache, but this can be restricted via the 'painless_enabled', 'mustache_enabled' 'expression_enabled' settings.NOTES: Not supported in 6.x. (Corresponds to the parameters 'script.engine.[painless|mustache|expressions].[file|stored|inline]')"
        }
      },
      "description": "Scripts can be stored in indexes ('stored'), or uploaded in file bundles ('file'), or used directly in API requests ('inline'). This object controls whether scripting is enabled for the given type, together with other fine grained control parameters."
    },
    "ElasticsearchScriptingUserSettings": {
      "type": "object",
      "properties": {
        "painless_enabled": {
          "type": "boolean",
          "description": "(5.x+ only) If enabled (the default) then the painless scripting engine is allowed as a sandboxed language. Sandboxed languages are the only ones allowed if 'sandbox_mode' is set to true. NOTES: (Corresponds to the parameters 'script.engine.painless.[file|stored|inline]')"
        },
        "mustache_enabled": {
          "type": "boolean",
          "description": "(5.x+ only) If enabled (the default) then the mustache scripting engine is allowed as a sandboxed language. Sandboxed languages are the only ones allowed if 'sandbox_mode' is set to true. NOTES: (Corresponds to the parameters 'script.engine.mustache.[file|stored|inline]')"
        },
        "expressions_enabled": {
          "type": "boolean",
          "description": "(5.x+ only) If enabled (the default) then the expressions scripting engine is allowed as a sandboxed language. Sandboxed languages are the only ones allowed if 'sandbox_mode' is set to true. NOTES: (Corresponds to the parameters 'script.engine.expression.[file|stored|inline]')"
        },
        "stored": {
          "$ref": "#/definitions/ElasticsearchScriptTypeSettings"
        },
        "file": {
          "$ref": "#/definitions/ElasticsearchScriptTypeSettings"
        },
        "inline": {
          "$ref": "#/definitions/ElasticsearchScriptTypeSettings"
        }
      },
      "description": "Controls the different 'languages' (painless/mustache/expressions) supported by the Elasticsearch cluster, and the different ways they can be used (file, index, inline). More complex configurations need to be handled by leaving these blank and controlling instead in the user YAML or JSON"
    },
    "ElasticsearchSystemSettings": {
      "type": "object",
      "properties": {
        "scripting": {
          "$ref": "#/definitions/ElasticsearchScriptingUserSettings"
        },
        "reindex_whitelist": {
          "type": "array",
          "description": "Limits remote Elasticsearch clusters that can be used as the source for '_reindex' API commands",
          "items": {
            "type": "string"
          }
        },
        "use_disk_threshold": {
          "type": "boolean",
          "description": "Whether to factor in the available disk space on a node before deciding whether to allocate new shards to that node or actively relocate shards away from the node (default: true). NOTES: (Corresponds to the parameter 'cluster.routing.allocation.disk.threshold_enabled')"
        },
        "auto_create_index": {
          "type": "boolean",
          "description": "If true (the default), then any write operation on an index that does not currently exist will create it. NOTES: (Corresponds to the parameter 'action.auto_create_index')"
        },
        "enable_close_index": {
          "type": "boolean",
          "description": "If false (the default), then the API commands to close indices are disabled. This is important because Elasticsearch does not snapshot or migrate close indices, therefore standard Elastic Cloud configuration operations will cause irretrievable loss of indices' data. NOTES: (Corresponds to the parameter 'cluster.indices.close.enable')"
        },
        "destructive_requires_name": {
          "type": "boolean",
          "description": "If true (default is false) then the index deletion API will not support wildcards or '_all'. NOTES: (Corresponds to the parameter 'action.destructive_requires_name')"
        },
        "watcher_trigger_engine": {
          "type": "string",
          "description": "The trigger engine for Watcher, defaults to 'scheduler' - see the xpack documentation for more information. NOTES: (Corresponds to the parameter '(xpack.)watcher.trigger.schedule.engine', depending on version. Ignored from 6.x onwards.)"
        },
        "default_shards_per_index": {
          "type": "integer",
          "format": "int32",
          "description": "(2.x only - to get the same result in 5.x template mappings must be used) Sets the default number of shards per index, defaulting to 1 if not specified. (Corresponds to the parameter 'index.number_of_shards' in 2.x, not supported in 5.x)"
        },
        "monitoring_collection_interval": {
          "type": "integer",
          "format": "int32",
          "description": "The default interval at which monitoring information from the cluster if collected, if monitoring is enabled. NOTES: (Corresponds to the parameter 'marvel.agent.interval' in 2.x and 'xpack.monitoring.collection.interval' in 5.x)"
        },
        "monitoring_history_duration": {
          "type": "string",
          "description": "The duration for which monitoring history is stored (format '(NUMBER)d' eg '3d' for 3 days). NOTES: ('Corresponds to the parameter xpack.monitoring.history.duration' in 5.x, defaults to '7d')"
        }
      },
      "description": "This structure defines a curated subset of the Elasticsearch settings that are of particular relevance to ECE. (This field together with 'user_settings_override*' and  'user_settings*' defines the total set of Elasticsearch settings)"
    },
    "ElasticsearchUserBundle": {
      "type": "object",
      "required": [
        "elasticsearch_version",
        "name",
        "url"
      ],
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the bundle"
        },
        "url": {
          "type": "string",
          "description": "The URL of the bundle (must be accessible from the ECE infrastructure)"
        },
        "elasticsearch_version": {
          "type": "string",
          "description": "The supported Elasticsearch version (must match the version in the plan)"
        }
      },
      "description": "A list of admin-uploaded bundle objects (eg scripts, synonym files) that are available for this user. Not yet supported in ECE, SaaS only"
    },
    "ElasticsearchUserPlugin": {
      "type": "object",
      "required": [
        "elasticsearch_version",
        "name",
        "url"
      ],
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the plugin"
        },
        "url": {
          "type": "string",
          "description": "The URL of the plugin (must be accessible from the ECE infrastructure)"
        },
        "elasticsearch_version": {
          "type": "string",
          "description": "The supported Elasticsearch version (must match the version in the plan)"
        }
      },
      "description": "A list of admin-uploaded plugin objects that are available for this user. Not yet supported in ECE, SaaS only"
    },
    "KibanaClusterPlan": {
      "type": "object",
      "required": [
        "kibana",
        "zone_count"
      ],
      "properties": {
        "zone_count": {
          "type": "integer",
          "format": "int32",
          "description": "The number of zones in which data nodes will be placed"
        },
        "cluster_topology": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/KibanaClusterTopologyElement"
          }
        },
        "kibana": {
          "$ref": "#/definitions/KibanaConfiguration"
        },
        "transient": {
          "$ref": "#/definitions/TransientKibanaPlanConfiguration"
        }
      }
    },
    "KibanaClusterTopologyElement": {
      "type": "object",
      "required": [
        "memory_per_node",
        "node_count_per_zone"
      ],
      "properties": {
        "memory_per_node": {
          "type": "integer",
          "format": "int32",
          "description": "The memory capacity in MB for each node of this type built in each zone"
        },
        "node_count_per_zone": {
          "type": "integer",
          "format": "int32",
          "description": "The number of nodes of this type that are allocated within each zone"
        },
        "allocator_filter": {
          "type": "object",
          "description": "DEPRECATED: Controls the allocation strategy of this node type using a simplified version of the Elasticsearch filter DSL (together with 'node_configuration')"
        },
        "node_configuration": {
          "type": "string",
          "description": "Controls the allocation strategy of this node type by pointing to the names of pre-registered allocator settings. Unless otherwise specified for this deployment, should be omitted."
        }
      },
      "description": "Defines the topology of the Kibana nodes (eg number/capacity of nodes, and where they can be allocated)"
    },
    "KibanaConfiguration": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "description": "The version of the Kibana cluster (must be one of the ECE supported versions, and won't work unless it matches the Elasticsearch version. Leave blank to auto-detect version.)"
        },
        "docker_image": {
          "type": "string",
          "description": "A docker URI that allows overriding of the default docker image specified for this version"
        },
        "system_settings": {
          "$ref": "#/definitions/KibanaSystemSettings"
        },
        "user_settings_json": {
          "type": "object",
          "description": "An arbitrary JSON object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user_settings_yaml' is allowed), provided they are on the whitelist ('user_settings_whitelist') and not on the blacklist ('user_settings_blacklist'). (This field together with 'user_settings_override*' and 'system_settings' defines the total set of Kibana settings)"
        },
        "user_settings_yaml": {
          "type": "string",
          "description": "An arbitrary YAML object allowing (non-admin) cluster owners to set their parameters (only one of this and 'user_settings_json' is allowed), provided they are on the whitelist ('user_settings_whitelist') and not on the blacklist ('user_settings_blacklist'). (These field together with 'user_settings_override*' and 'system_settings' defines the total set of Kibana settings)"
        },
        "user_settings_override_json": {
          "type": "object",
          "description": "An arbitrary JSON object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_yaml' is allowed), ie in addition to the documented 'system_settings'. (This field together with 'system_settings' and 'user_settings*' defines the total set of Kibana settings)"
        },
        "user_settings_override_yaml": {
          "type": "string",
          "description": "An arbitrary YAML object allowing ECE admins owners to set clusters' parameters (only one of this and 'user_settings_override_json' is allowed), ie in addition to the documented 'system_settings'. (This field together with 'system_settings' and 'user_settings*' defines the total set of Kibana settings)"
        }
      }
    },
    "KibanaSystemSettings": {
      "type": "object",
      "properties": {
        "elasticsearch_url": {
          "type": "string",
          "description": "Optionally override the URL to which to send data (for advanced users only, if unspecified the system selects an internal URL)"
        },
        "elasticsearch_username": {
          "type": "string",
          "description": "Optionally override the account within Elasticsearch - defaults to a system account that always exists (if specified, the password must also be specified)"
        },
        "elasticsearch_password": {
          "type": "string",
          "description": "Optionally override the account within Elasticsearch - defaults to a system account that always exists (if specified, the username must also be specified)"
        }
      },
      "description": "This structure defines a curated subset of the Kibana settings that are of particular relevance to ECE. (This field together with 'user_settings_override*' and  'user_settings*' defines the total set of Elasticsearch settings)"
    },
    "ManagedMonitoringSettings": {
      "type": "object",
      "required": [
        "target_cluster_id"
      ],
      "properties": {
        "target_cluster_id": {
          "type": "string",
          "description": "The Id of the target cluster to which to send monitoring information"
        }
      },
      "description": "Settings for sending monitoring information to another cluster"
    },
    "ManagedSnapshotSettings": {
      "type": "object",
      "required": [
        "repository_name"
      ],
      "properties": {
        "repository_name": {
          "type": "string",
          "description": "ECE snapshot repository name, from the '/platform/configuration/snapshots/repositories' endpoint"
        },
        "interval": {
          "type": "string",
          "description": "Interval between snapshots, with the format 'length unit' (space is optional), where unit can be one of: d (day), h (hour), min (minute). Default is 30 minutes"
        }
      },
      "description": "Configures how ECE takes snapshots for Elasticsearch clusters"
    },
    "TiebreakerTopologyElement": {
      "type": "object",
      "required": [
        "memory_per_node"
      ],
      "properties": {
        "memory_per_node": {
          "type": "integer",
          "format": "int32",
          "description": "The memory capacity in MB for the tiebreaker node. NOTES: (Only powers of 2 starting with 1024 are supported. Will fail to allocate if too much memory is requested)"
        }
      },
      "description": "Defines the topology (capacity and location) of the special tiebreaker node. If masters nodes are present, their topology acts as a default for the tiebreaker topology"
    },
    "ElasticsearchClusterInstanceSettingsOverrides": {
      "type": "object",
      "properties": {
        "instance_capacity": {
          "type": "integer",
          "format": "int32",
          "description": "Sets the memory capacity for the instance's container. Requires a restart to take effect."
        }
      },
      "description": "Elasticsearch instance settings overrides"
    },
    "CreateKibanaClusterRequest": {
      "type": "object",
      "required": [
        "elasticsearch_cluster_id",
        "plan"
      ],
      "properties": {
        "cluster_name": {
          "type": "string",
          "description": "The human readable name for the Kibana cluster (default: takes the name of its Elasticsearch cluster)"
        },
        "elasticsearch_cluster_id": {
          "type": "string",
          "description": "The Id of the Elasticsearch cluster to which this Kibana will be connected"
        },
        "plan": {
          "$ref": "#/definitions/KibanaClusterPlan"
        }
      },
      "description": "The body of a request to create a new Kibana cluster"
    },
    "ChangeSourceInfo": {
      "type": "object",
      "required": [
        "action",
        "date",
        "facilitator"
      ],
      "properties": {
        "facilitator": {
          "type": "string",
          "description": "The service where the change originated from"
        },
        "action": {
          "type": "string",
          "description": "The type of plan change that was initiated"
        },
        "date": {
          "type": "string",
          "format": "date-time",
          "description": "The time the change was initiated"
        },
        "user_id": {
          "type": "string",
          "description": "The user that requested the change"
        },
        "admin_id": {
          "type": "string",
          "description": "The admin user that requested the change"
        },
        "remote_addresses": {
          "type": "array",
          "description": "The host addresses of the user that originated the change",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "A container for information about the source of a change."
    },
    "ClusterInstanceDiskInfo": {
      "type": "object",
      "required": [
        "disk_space_used"
      ],
      "properties": {
        "disk_space_available": {
          "type": "integer",
          "format": "int64",
          "description": "If known, the amount of disk space available to the container in MB"
        },
        "disk_space_used": {
          "type": "integer",
          "format": "int64",
          "description": "The amount of disk space being used by the service in MB"
        }
      },
      "description": "Information about the instance's storage capacity and use"
    },
    "ClusterInstanceInfo": {
      "type": "object",
      "required": [
        "container_started",
        "healthy",
        "instance_name",
        "maintenance_mode",
        "service_running"
      ],
      "properties": {
        "instance_name": {
          "type": "string",
          "description": "Whether the instance is healthy (ie started and running)"
        },
        "service_version": {
          "type": "string",
          "description": "The version of the service that the instance is running (eg Elasticsearch or Kibana), if available"
        },
        "service_id": {
          "type": "string",
          "description": "The service-specific (eg Elasticsearch) id of the node, if available"
        },
        "healthy": {
          "type": "boolean",
          "description": "Whether the instance is healthy (ie started and running)"
        },
        "container_started": {
          "type": "boolean",
          "description": "Whether the container has started (does not tell you anything about the service -ie Elasticsearch- running inside the container)"
        },
        "service_running": {
          "type": "boolean",
          "description": "Whether the service launched inside the container -ie Elasticsearch- is actually running"
        },
        "maintenance_mode": {
          "type": "boolean",
          "description": "Whether the service is is maintenance mode (meaning that the proxy is not routing external traffic to it)"
        },
        "zone": {
          "type": "string",
          "description": "The zone in which this instance is being allocated"
        },
        "allocator_id": {
          "type": "string",
          "description": "The id of the allocator on which this instance is running (if the container is started or starting)"
        },
        "memory": {
          "$ref": "#/definitions/ClusterInstanceMemoryInfo"
        },
        "disk": {
          "$ref": "#/definitions/ClusterInstanceDiskInfo"
        },
        "service_roles": {
          "type": "array",
          "description": "List of roles assigned to the service running in the instance. Currently only populated for Elasticsearch, with possible values: master,data,ingest",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "Information about each instance in a cluster"
    },
    "ClusterInstanceMemoryInfo": {
      "type": "object",
      "required": [
        "instance_capacity"
      ],
      "properties": {
        "instance_capacity": {
          "type": "integer",
          "format": "int32",
          "description": "The memory capacity in MB of the instance"
        },
        "memory_pressure": {
          "type": "integer",
          "format": "int32",
          "description": "The % memory pressure of the service if available (60-75% consider increasing capacity, >75% can incur significant performance and stability issues)"
        }
      },
      "description": "Information about the instance's memory capacity and use"
    },
    "ClusterMetadataInfo": {
      "type": "object",
      "required": [
        "last_modified",
        "version"
      ],
      "properties": {
        "version": {
          "type": "integer",
          "format": "int32",
          "description": "The resource version number of the cluster metadata"
        },
        "last_modified": {
          "type": "string",
          "format": "date-time",
          "description": "The most recent time the cluster metadata was changed (ISO format in UTC)"
        },
        "endpoint": {
          "type": "string",
          "description": "The DNS name of the cluster endpoint, if available"
        },
        "raw": {
          "type": "object",
          "description": "An unstructured JSON representation of the public and internal state (can be filtered out via URL parameter)"
        }
      },
      "description": "The cluster metadata stores a combination of public and internal state and configuration for a cluster. The unstructured content is undocumented unless explicitly stated elsewhere in the docs"
    },
    "ClusterPlanStepInfo": {
      "type": "object",
      "required": [
        "info_log",
        "stage",
        "started",
        "status",
        "step_id"
      ],
      "properties": {
        "step_id": {
          "type": "string",
          "description": "ID of current step"
        },
        "started": {
          "type": "string",
          "format": "date-time",
          "description": "When the step started (ISO format in UTC)"
        },
        "completed": {
          "type": "string",
          "format": "date-time",
          "description": "When the step completed (ISO format in UTC)"
        },
        "duration_in_millis": {
          "type": "integer",
          "format": "int64",
          "description": "The duration of the step in MS"
        },
        "status": {
          "type": "string",
          "description": "The status of the step (success, warning, error - warning means something didn't go as expected but it was not serious enough to abort the plan)",
          "enum": [
            "success",
            "warning",
            "error",
            "pending"
          ]
        },
        "stage": {
          "type": "string",
          "description": "Current stage that the step is in",
          "enum": [
            "starting",
            "completed",
            "in_progress"
          ]
        },
        "info_log": {
          "type": "array",
          "description": "Human readable summaries of the step, including messages for each stage of the step",
          "items": {
            "$ref": "#/definitions/ClusterPlanStepLogMessageInfo"
          }
        }
      },
      "description": "A log of information each step taken during a plan attempt"
    },
    "ClusterPlanStepLogMessageInfo": {
      "type": "object",
      "required": [
        "message",
        "stage",
        "timestamp"
      ],
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp marking on info log of step"
        },
        "delta_in_millis": {
          "type": "integer",
          "format": "int64",
          "description": "Time in milliseconds since previous log message"
        },
        "stage": {
          "type": "string",
          "description": "Stage that info log message takes place in",
          "enum": [
            "starting",
            "completed",
            "in_progress"
          ]
        },
        "message": {
          "type": "string",
          "description": "Human readable log message"
        }
      },
      "description": "One log message occurring during a given stage of a step"
    },
    "ClusterSystemAlert": {
      "type": "object",
      "required": [
        "alert_type",
        "instance_name",
        "timestamp"
      ],
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp marking the system alert"
        },
        "instance_name": {
          "type": "string",
          "description": "Instance that caused the system alert"
        },
        "alert_type": {
          "type": "string",
          "description": "Type of system alert",
          "enum": [
            "automatic_restart",
            "unknown_event"
          ]
        }
      },
      "description": "Information about a system alert that has happened on a cluster"
    },
    "ClusterTopologyInfo": {
      "type": "object",
      "required": [
        "healthy",
        "instances"
      ],
      "properties": {
        "healthy": {
          "type": "boolean",
          "description": "Whether the cluster topology is healthy (ie all instances are started and the services they run - ie elasticsearch - are available"
        },
        "instances": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ClusterInstanceInfo"
          }
        }
      },
      "description": "A description of the cluster topology (the different instances/containers making up the cluster, and where they are located"
    },
    "ElasticsearchClusterBlockingIssueElement": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string",
          "description": "Description of the issue"
        },
        "instances": {
          "type": "array",
          "description": "A list of instances that are affected by the issue",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "Provides detailed information about an issue and the instances it affects"
    },
    "ElasticsearchClusterBlockingIssues": {
      "type": "object",
      "properties": {
        "healthy": {
          "type": "boolean",
          "description": "Whether the cluster has issues (false) or not (true)"
        },
        "cluster_level": {
          "type": "array",
          "description": "A list of issues that affect availability of entire cluster",
          "items": {
            "$ref": "#/definitions/ElasticsearchClusterBlockingIssueElement"
          }
        },
        "index_level": {
          "type": "array",
          "description": "A list of issues that affect availability of the cluster's indices",
          "items": {
            "$ref": "#/definitions/ElasticsearchClusterBlockingIssueElement"
          }
        }
      },
      "description": "Information about issues that prevent either whole cluster or a particular index from operating correctly"
    },
    "ElasticsearchClusterInfo": {
      "type": "object",
      "required": [
        "associated_kibana_clusters",
        "cluster_id",
        "cluster_name",
        "elasticsearch",
        "external_links",
        "healthy",
        "metadata",
        "plan_info",
        "snapshots",
        "topology"
      ],
      "properties": {
        "cluster_id": {
          "type": "string",
          "description": "The id of the cluster"
        },
        "cluster_name": {
          "type": "string",
          "description": "The name of the cluster"
        },
        "healthy": {
          "type": "boolean",
          "description": "Whether the cluster is healthy or not (one or more of the info subsections will have healthy: false)"
        },
        "status": {
          "type": "string",
          "description": "Cluster status",
          "readOnly": true,
          "enum": [
            "Initializing",
            "Stopping",
            "Stopped",
            "Rebooting",
            "Restarting",
            "Reconfiguring",
            "Started"
          ]
        },
        "plan_info": {
          "$ref": "#/definitions/ElasticsearchClusterPlansInfo"
        },
        "elasticsearch": {
          "$ref": "#/definitions/ElasticsearchInfo"
        },
        "metadata": {
          "$ref": "#/definitions/ClusterMetadataInfo"
        },
        "topology": {
          "$ref": "#/definitions/ClusterTopologyInfo"
        },
        "system_alerts": {
          "type": "array",
          "description": "List of cluster system alerts",
          "items": {
            "$ref": "#/definitions/ClusterSystemAlert"
          }
        },
        "associated_kibana_clusters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/KibanaSubClusterInfo"
          }
        },
        "security": {
          "$ref": "#/definitions/ElasticsearchClusterSecurityInfo"
        },
        "elasticsearch_monitoring_info": {
          "$ref": "#/definitions/ElasticsearchMonitoringInfo"
        },
        "snapshots": {
          "$ref": "#/definitions/SnapshotStatusInfo"
        },
        "external_links": {
          "type": "array",
          "description": "External resources related to the cluster",
          "uniqueItems": true,
          "items": {
            "$ref": "#/definitions/ExternalHyperlink"
          }
        },
        "links": {
          "type": "object",
          "description": "A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation",
          "additionalProperties": {
            "$ref": "#/definitions/Hyperlink"
          }
        }
      },
      "description": "The top level info object for an Elasticsearch cluster"
    },
    "ElasticsearchClusterPlanInfo": {
      "type": "object",
      "required": [
        "attempt_start_time",
        "healthy",
        "plan_attempt_log"
      ],
      "properties": {
        "plan_attempt_id": {
          "type": "string",
          "description": "A UUID for each plan attempt"
        },
        "plan_attempt_name": {
          "type": "string",
          "description": "A human readable name for each plan attempt, only populated when retrieving plan histories"
        },
        "healthy": {
          "type": "boolean",
          "description": "Either the plan ended successfully, or is not yet completed (and no errors have occurred)"
        },
        "attempt_start_time": {
          "type": "string",
          "format": "date-time",
          "description": "When this plan attempt (ie to apply the plan to the cluster) started (ISO format in UTC)"
        },
        "attempt_end_time": {
          "type": "string",
          "format": "date-time",
          "description": "If this plan completed or failed (ie is not pending), when the attempt ended (ISO format in UTC)"
        },
        "plan_end_time": {
          "type": "string",
          "format": "date-time",
          "description": "If this plan is not current or pending, when the plan was no longer active (ISO format in UTC)"
        },
        "plan": {
          "$ref": "#/definitions/ElasticsearchClusterPlan"
        },
        "plan_attempt_log": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ClusterPlanStepInfo"
          }
        },
        "source": {
          "description": "Information describing the source that facilitated the plans current state",
          "$ref": "#/definitions/ChangeSourceInfo"
        }
      },
      "description": "Information about a current, pending, or past plan"
    },
    "ElasticsearchClusterPlansInfo": {
      "type": "object",
      "required": [
        "healthy",
        "history"
      ],
      "properties": {
        "healthy": {
          "type": "boolean",
          "description": "Whether the plan situation is healthy (if unhealthy, means the last plan attempt failed)"
        },
        "current": {
          "$ref": "#/definitions/ElasticsearchClusterPlanInfo"
        },
        "pending": {
          "$ref": "#/definitions/ElasticsearchClusterPlanInfo"
        },
        "history": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ElasticsearchClusterPlanInfo"
          }
        }
      },
      "description": "Information about the current, pending, and past plans of a cluster"
    },
    "ElasticsearchClusterRole": {
      "type": "object",
      "required": [
        "roles",
        "username"
      ],
      "properties": {
        "username": {
          "type": "string",
          "description": "The username"
        },
        "roles": {
          "type": "array",
          "description": "The list of roles for this user",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "A list of users together with that user's roles"
    },
    "ElasticsearchClusterSecurityInfo": {
      "type": "object",
      "required": [
        "allow_anonymous",
        "last_modified",
        "roles",
        "users",
        "users_roles",
        "version"
      ],
      "properties": {
        "version": {
          "type": "integer",
          "format": "int32",
          "description": "The resource version number of the security settings"
        },
        "last_modified": {
          "type": "string",
          "format": "date-time",
          "description": "The most recent time the security settings were changed (ISO format in UTC)"
        },
        "allow_anonymous": {
          "type": "boolean",
          "description": "Whether anonymous access to the cluster is allowed"
        },
        "users": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ElasticsearchClusterUser"
          }
        },
        "roles": {
          "type": "object",
          "description": "An arbitrarily nested JSON object mapping roles to sets of resources and permissions - see the Elasticsearch security documentation for more details on roles"
        },
        "users_roles": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ElasticsearchClusterRole"
          }
        }
      },
      "description": "For 2.x clusters, information about the users and roles. For 5.x, the Kibana management UI should be used"
    },
    "ElasticsearchClusterUser": {
      "type": "object",
      "required": [
        "password_hash",
        "username"
      ],
      "properties": {
        "username": {
          "type": "string",
          "description": "The username"
        },
        "password_hash": {
          "type": "string",
          "description": "The hashed password"
        }
      },
      "description": "A list of users together with their password hash"
    },
    "ElasticsearchClustersInfo": {
      "type": "object",
      "required": [
        "elasticsearch_clusters",
        "return_count"
      ],
      "properties": {
        "return_count": {
          "type": "integer",
          "format": "int32",
          "description": "The number of clusters actually returned"
        },
        "elasticsearch_clusters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ElasticsearchClusterInfo"
          }
        }
      },
      "description": "A container for information about on a set of the Elasticsearch clusters"
    },
    "ElasticsearchInfo": {
      "type": "object",
      "required": [
        "healthy",
        "master_info",
        "shard_info"
      ],
      "properties": {
        "healthy": {
          "type": "boolean",
          "description": "Whether the Elasticsearch cluster is healthy (check the sub-objects for more details if not)"
        },
        "shard_info": {
          "$ref": "#/definitions/ElasticsearchShardsInfo"
        },
        "master_info": {
          "$ref": "#/definitions/ElasticsearchMasterInfo"
        },
        "blocking_issues": {
          "$ref": "#/definitions/ElasticsearchClusterBlockingIssues"
        }
      },
      "description": "Information about the Elasticsearch cluster (indices, masters)"
    },
    "ElasticsearchMasterElement": {
      "type": "object",
      "required": [
        "instances",
        "master_node_id"
      ],
      "properties": {
        "master_node_id": {
          "type": "string",
          "description": "The Elasticsearch node id of a master node"
        },
        "master_instance_name": {
          "type": "string",
          "description": "The corresponding instance name of the container hosting the Elasticsearch master node, if available"
        },
        "instances": {
          "type": "array",
          "description": "The names of the instance/container hosting the node belong to the cluster with the given master",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "More detailed information about which instances are port the cluster (or sub-clusters in the case of split brain)"
    },
    "ElasticsearchMasterInfo": {
      "type": "object",
      "required": [
        "healthy",
        "instances_with_no_master",
        "masters"
      ],
      "properties": {
        "healthy": {
          "type": "boolean",
          "description": "Whether the master situation in the cluster is healthy (ie is the number of masters != 1), or do any instances have no master"
        },
        "masters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ElasticsearchMasterElement"
          }
        },
        "instances_with_no_master": {
          "type": "array",
          "description": "A list of any instances with no master",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "Information about the master node(s) in the Elasticsearch cluster"
    },
    "ElasticsearchMonitoringInfo": {
      "type": "object",
      "required": [
        "destination_cluster_ids",
        "healthy",
        "last_modified",
        "last_update_status",
        "source_cluster_ids"
      ],
      "properties": {
        "healthy": {
          "type": "boolean",
          "description": "Whether the Monitoring configuration has been successfully applied"
        },
        "last_modified": {
          "type": "string",
          "format": "date-time",
          "description": "The time the monitoring configuration was last changed"
        },
        "last_update_status": {
          "type": "string",
          "description": "The status message from the last update (successful or not)"
        },
        "source_cluster_ids": {
          "type": "array",
          "description": "The list of clusters Ids from which this cluster is currently receiving monitoring data",
          "items": {
            "type": "string"
          }
        },
        "destination_cluster_ids": {
          "type": "array",
          "description": "The list of clusters Ids to which this cluster is currently sending monitoring data",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "Information about this cluster's ECE-managed XPack Monitoring status"
    },
    "ElasticsearchReplicaElement": {
      "type": "object",
      "required": [
        "instance_name",
        "replica_count"
      ],
      "properties": {
        "instance_name": {
          "type": "string",
          "description": "The Elastic Cloud name/id of the instance (container)"
        },
        "replica_count": {
          "type": "integer",
          "format": "int32",
          "description": "The number of unavailable replicas on this instance"
        }
      },
      "description": "Information about the unavailable replicas - unlike with shards, unavailable replicas means a loss of redundancy rather than a loss of availability"
    },
    "ElasticsearchShardElement": {
      "type": "object",
      "required": [
        "instance_name",
        "shard_count"
      ],
      "properties": {
        "instance_name": {
          "type": "string",
          "description": "The Elastic Cloud name/id of the instance (container)"
        },
        "shard_count": {
          "type": "integer",
          "format": "int32",
          "description": "The number of shards of the given type (available/unavailable) on this instance"
        }
      },
      "description": "Information about the shards of different types (available and unavailable - unavailable is bad and means that a cluster cannot serve all its data) for each instance container hosting an Elasticsearch node"
    },
    "ElasticsearchShardsInfo": {
      "type": "object",
      "required": [
        "available_shards",
        "healthy",
        "unavailable_replicas",
        "unavailable_shards"
      ],
      "properties": {
        "healthy": {
          "type": "boolean",
          "description": "Whether the shard situation is healthy (any unavailable shards is unhealthy)"
        },
        "available_shards": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ElasticsearchShardElement"
          }
        },
        "unavailable_shards": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ElasticsearchShardElement"
          }
        },
        "unavailable_replicas": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ElasticsearchReplicaElement"
          }
        }
      },
      "description": "Information about the shards (and replicas) that comprise the Elasticsearch indices"
    },
    "ExternalHyperlink": {
      "type": "object",
      "required": [
        "id",
        "label"
      ],
      "properties": {
        "id": {
          "type": "string",
          "description": "Identifier of the external link"
        },
        "label": {
          "type": "string",
          "description": "Human-readable description of the external link"
        },
        "uri": {
          "type": "string",
          "description": "hyperlink to an external resource"
        }
      }
    },
    "Hyperlink": {
      "type": "object",
      "properties": {
        "sudo_required": {
          "type": "boolean",
          "description": "Whether this operation requires sudo (it doesn't if the field isn't present)"
        }
      }
    },
    "KibanaSubClusterInfo": {
      "type": "object",
      "required": [
        "enabled",
        "kibana_id"
      ],
      "properties": {
        "kibana_id": {
          "type": "string",
          "description": "The Kibana cluster Id"
        },
        "enabled": {
          "type": "boolean",
          "description": "Whether the associated Kibana cluster is currently available"
        },
        "links": {
          "type": "object",
          "description": "A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation",
          "additionalProperties": {
            "$ref": "#/definitions/Hyperlink"
          }
        }
      },
      "description": "Information about any Kibana clusters associated with this Elasticsearch cluster"
    },
    "SnapshotStatusInfo": {
      "type": "object",
      "required": [
        "count",
        "healthy"
      ],
      "properties": {
        "healthy": {
          "type": "boolean",
          "description": "Health status of snapshots for this cluster"
        },
        "count": {
          "type": "integer",
          "format": "int32",
          "description": "Number of snapshots stored for this cluster"
        },
        "latest_successful": {
          "type": "boolean",
          "description": "Latest snapshot status"
        },
        "latest_status": {
          "type": "string",
          "description": "Status of the latest snapshot attempt, if any exist."
        },
        "scheduled_time": {
          "type": "string",
          "format": "date-time",
          "description": "Scheduled time of next snapshot attempt"
        },
        "latest_end_time": {
          "type": "string",
          "format": "date-time",
          "description": "The end time of the most recently attempted snapshot"
        },
        "latest_successful_end_time": {
          "type": "string",
          "format": "date-time",
          "description": "The end time of the most recently successful snapshot"
        }
      },
      "description": "Information about this cluster's snapshot status (health, etc.)"
    },
    "KibanaClusterInfo": {
      "type": "object",
      "required": [
        "cluster_id",
        "cluster_name",
        "elasticsearch_cluster",
        "external_links",
        "healthy",
        "metadata",
        "plan_info",
        "topology"
      ],
      "properties": {
        "cluster_id": {
          "type": "string",
          "description": "The id of the cluster"
        },
        "cluster_name": {
          "type": "string",
          "description": "The name of the cluster"
        },
        "elasticsearch_cluster": {
          "$ref": "#/definitions/TargetElasticsearchCluster"
        },
        "healthy": {
          "type": "boolean",
          "description": "Whether the cluster is healthy or not (one or more of the info subsections will have healthy: false)"
        },
        "status": {
          "type": "string",
          "description": "Cluster status",
          "readOnly": true,
          "enum": [
            "Initializing",
            "Stopping",
            "Stopped",
            "Rebooting",
            "Restarting",
            "Reconfiguring",
            "Started"
          ]
        },
        "plan_info": {
          "$ref": "#/definitions/KibanaClusterPlansInfo"
        },
        "metadata": {
          "$ref": "#/definitions/ClusterMetadataInfo"
        },
        "topology": {
          "$ref": "#/definitions/ClusterTopologyInfo"
        },
        "external_links": {
          "type": "array",
          "description": "External resources related to the cluster",
          "uniqueItems": true,
          "items": {
            "$ref": "#/definitions/ExternalHyperlink"
          }
        },
        "links": {
          "type": "object",
          "description": "A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation",
          "additionalProperties": {
            "$ref": "#/definitions/Hyperlink"
          }
        }
      },
      "description": "The top level info object for a Kibana cluster"
    },
    "KibanaClusterPlanInfo": {
      "type": "object",
      "required": [
        "attempt_start_time",
        "healthy",
        "plan_attempt_log"
      ],
      "properties": {
        "plan_attempt_id": {
          "type": "string",
          "description": "A UUID for each plan attempt"
        },
        "plan_attempt_name": {
          "type": "string",
          "description": "A human readable name for each plan attempt, only populated when retrieving plan histories"
        },
        "healthy": {
          "type": "boolean",
          "description": "Either the plan ended successfully, or is not yet completed (and no errors have occurred)"
        },
        "attempt_start_time": {
          "type": "string",
          "format": "date-time",
          "description": "When this plan attempt (ie to apply the plan to the cluster) started (ISO format in UTC)"
        },
        "attempt_end_time": {
          "type": "string",
          "format": "date-time",
          "description": "If this plan completed or failed (ie is not pending), when the attempt ended (ISO format in UTC)"
        },
        "plan_end_time": {
          "type": "string",
          "format": "date-time",
          "description": "If this plan is not current or pending, when the plan was no longer active (ISO format in UTC)"
        },
        "plan": {
          "$ref": "#/definitions/KibanaClusterPlan"
        },
        "plan_attempt_log": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ClusterPlanStepInfo"
          }
        },
        "source": {
          "description": "Information describing the source that facilitated the plans current state",
          "$ref": "#/definitions/ChangeSourceInfo"
        }
      },
      "description": "Information about a current, pending, or past plan"
    },
    "KibanaClusterPlansInfo": {
      "type": "object",
      "required": [
        "healthy",
        "history"
      ],
      "properties": {
        "healthy": {
          "type": "boolean",
          "description": "Whether the plan situation is healthy (if unhealthy, means the last plan attempt failed)"
        },
        "current": {
          "$ref": "#/definitions/KibanaClusterPlanInfo"
        },
        "pending": {
          "$ref": "#/definitions/KibanaClusterPlanInfo"
        },
        "history": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/KibanaClusterPlanInfo"
          }
        }
      },
      "description": "Information about the current, pending, and past plans of a cluster"
    },
    "KibanaClustersInfo": {
      "type": "object",
      "required": [
        "kibana_clusters",
        "return_count"
      ],
      "properties": {
        "return_count": {
          "type": "integer",
          "format": "int32",
          "description": "The number of clusters actually returned"
        },
        "kibana_clusters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/KibanaClusterInfo"
          }
        }
      },
      "description": "A container for information about on a set of the Kibana clusters"
    },
    "TargetElasticsearchCluster": {
      "type": "object",
      "required": [
        "elasticsearch_id"
      ],
      "properties": {
        "elasticsearch_id": {
          "type": "string",
          "description": "The Elasticsearch cluster Id"
        },
        "links": {
          "type": "object",
          "description": "A map of application-specific operations (which map to 'operationId's in the Swagger API) to metadata about that operation",
          "additionalProperties": {
            "$ref": "#/definitions/Hyperlink"
          }
        }
      },
      "description": "Information about any Kibana clusters associated with this Elasticsearch cluster"
    },
    "ClusterMetadataSettings": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The display name of the cluster"
        },
        "owner_id": {
          "type": "string",
          "description": "The user id (referencing whatever user database is in use) of the cluster owner"
        },
        "subscription_level": {
          "type": "string",
          "description": "Subscription level of the cluster"
        },
        "system_owned": {
          "type": "boolean",
          "description": "Indicates if a cluster is system owned (restricts the set of operations that can be performed on it)"
        },
        "contact_email": {
          "type": "string",
          "description": "Contact email for the cluster"
        }
      },
      "description": "The cluster metadata settings stores top level configuration for a cluster."
    },
    "PlatformInfo": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "description": "Platform version"
        },
        "services": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PlatformServiceInfo"
          }
        },
        "phone_home_enabled": {
          "type": "boolean",
          "description": "Is the phone-home service, which returns anonymized usage statistics to Elastic, enabled"
        },
        "eula_accepted": {
          "type": "boolean",
          "description": "Indicates if the End User License Agreement been accepted"
        }
      },
      "description": "Information about the platform"
    },
    "PlatformServiceImageInfo": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "example": "docker.elastic.co/elastic-cloud-enterprise:1.0.0-GA",
          "description": "Id of runner that hosts the container"
        },
        "tag": {
          "type": "string",
          "example": "docker.elastic.co/elastic-cloud-enterprise:1.0.0-GA",
          "description": "Image tag"
        },
        "version": {
          "type": "string",
          "example": "1.0.0-GA",
          "description": "Version of service"
        },
        "hash": {
          "type": "string",
          "example": "sha256:04a5be1ab07de64269ffa52da26044e0ecc36fa1164e7914468e69d65a2090d4",
          "description": "Image hash code"
        }
      },
      "description": "Details about a docker image that is used to run a service"
    },
    "PlatformServiceInfo": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "Name of service"
        },
        "image": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PlatformServiceImageInfo"
          }
        }
      },
      "description": "Platform service information"
    },
    "ListEnrollmentTokenElement": {
      "type": "object",
      "required": [
        "roles"
      ],
      "properties": {
        "token_id": {
          "type": "string",
          "description": "An identifier for the token"
        },
        "roles": {
          "type": "array",
          "description": "The services for which this enrollment token applies",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "Information about a currently active enrollment token"
    },
    "ListEnrollmentTokenReply": {
      "type": "object",
      "properties": {
        "tokens": {
          "type": "array",
          "description": "The list of currently active enrollment tokens",
          "items": {
            "$ref": "#/definitions/ListEnrollmentTokenElement"
          }
        }
      },
      "description": "Information about currently active enrollment tokens"
    },
    "RequestEnrollmentTokenReply": {
      "type": "object",
      "properties": {
        "token": {
          "type": "string",
          "description": "The requested token"
        },
        "token_id": {
          "type": "string",
          "description": "An identifier for the requested token (if persistent) that can be used in listing and deletion"
        }
      },
      "description": "Returns an enrollment token that can be used to start a new server with designated roles securely"
    },
    "EnrollmentTokenRequest": {
      "type": "object",
      "required": [
        "persistent"
      ],
      "properties": {
        "roles": {
          "type": "array",
          "description": "The additional services for which this enrollment token applies (empty if not specified, ie system services only)",
          "items": {
            "type": "string"
          }
        },
        "persistent": {
          "type": "boolean",
          "description": "Whether this token can subsequently to its grant be revoked from the UI"
        },
        "validity_in_seconds": {
          "type": "integer",
          "format": "int32",
          "description": "The time in seconds for which this token is valid (defaults to 1 hour). Currently this can only be set for ephemeral (persistent: false) tokens."
        }
      },
      "description": "A request for an enrollment token for one or more services"
    },
    "TlsPublicCertChain": {
      "type": "object",
      "required": [
        "chain",
        "user_supplied"
      ],
      "properties": {
        "user_supplied": {
          "type": "boolean",
          "description": "Was this certificate chain user supplied or automatically generated?"
        },
        "chain": {
          "type": "array",
          "description": "The list of PEM encoded X509 certificates that make up the certificate chain",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "The public portion of the certificate chain containing the PEM encoded server certificate, intermediate certificates and the CA certificate.  The private key, normally included in certificate chains, is omitted."
    },
    "RepositoryConfig": {
      "type": "object",
      "required": [
        "config",
        "repository_name"
      ],
      "properties": {
        "repository_name": {
          "type": "string",
          "description": "Elasticsearch snapshot repository name"
        },
        "config": {
          "type": "object",
          "description": "Elasticsearch configuration JSON for a snapshot repository"
        }
      },
      "description": "Snapshot repository configuration"
    },
    "RepositoryConfigs": {
      "type": "object",
      "properties": {
        "configs": {
          "type": "array",
          "description": "List of snapshot configurations",
          "items": {
            "$ref": "#/definitions/RepositoryConfig"
          }
        }
      },
      "description": "A list of snapshot repository configurations"
    },
    "SnapshotRepositoryConfiguration": {
      "type": "object",
      "required": [
        "settings",
        "type"
      ],
      "properties": {
        "type": {
          "type": "string",
          "description": "Repository type, (Currently supported: 's3')"
        },
        "settings": {
          "type": "object",
          "description": "Elasticsearch repository configuration settings JSON. See [Elasticsearch documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html) for more information"
        }
      },
      "description": "Represents an Elasticsearch snapshot repository configuration block."
    },
    "AllocatorSettings": {
      "type": "object",
      "properties": {
        "capacity": {
          "type": "integer",
          "format": "int32",
          "description": "A memory capacity (in MB) that overrides the capacity defined during installation"
        }
      },
      "description": "An Allocators settings"
    },
    "MoveClustersCommandResponse": {
      "type": "object",
      "properties": {
        "failures": {
          "description": "Detailed information about the clusters that failed to move.",
          "$ref": "#/definitions/MoveClustersDetails"
        },
        "moves": {
          "description": "Detailed information about the clusters being moved off the allocator.",
          "$ref": "#/definitions/MoveClustersDetails"
        }
      },
      "description": "Detailed information about the cluster move operations being performed."
    },
    "MoveClustersDetails": {
      "type": "object",
      "properties": {
        "elasticsearch_clusters": {
          "type": "array",
          "description": "Detailed information about the Elasticsearch clusters being moved.",
          "items": {
            "$ref": "#/definitions/MoveElasticsearchClusterDetails"
          }
        },
        "kibana_clusters": {
          "type": "array",
          "description": "Detailed information about the Kibana clusters being moved.",
          "items": {
            "$ref": "#/definitions/MoveKibanaClusterDetails"
          }
        }
      },
      "description": "Detailed information about the clusters that are being moved off the allocator."
    },
    "MoveElasticsearchClusterDetails": {
      "type": "object",
      "properties": {
        "cluster_id": {
          "type": "string",
          "description": "Identifier for the Elasticsearch cluster."
        },
        "calculated_plan": {
          "description": "If only validating the move, then the plan configuration that would be applied to the cluster.",
          "$ref": "#/definitions/TransientElasticsearchPlanConfiguration"
        },
        "errors": {
          "type": "array",
          "description": "A list of errors that occurred if the attempt to move the cluster failed.",
          "items": {
            "$ref": "#/definitions/BasicFailedReplyElement"
          }
        }
      },
      "description": "Detailed information about the Elasticsearch cluster being moved."
    },
    "MoveKibanaClusterDetails": {
      "type": "object",
      "properties": {
        "cluster_id": {
          "type": "string",
          "description": "Identifier for the Kibana cluster."
        },
        "calculated_plan": {
          "description": "If only validating the move, then the plan configuration that would be applied to the cluster.",
          "$ref": "#/definitions/TransientKibanaPlanConfiguration"
        },
        "errors": {
          "type": "array",
          "description": "A list of errors that occurred if the attempt to move the cluster failed.",
          "items": {
            "$ref": "#/definitions/BasicFailedReply"
          }
        }
      },
      "description": "Detailed information about the Kibana cluster being moved."
    },
    "MoveClustersRequest": {
      "type": "object",
      "properties": {
        "elasticsearch_clusters": {
          "type": "array",
          "description": "Optional list of Elasticsearch clusters to move off the allocator. If not specified, then all Elasticsearch clusters on the allocator are moved.",
          "items": {
            "$ref": "#/definitions/MoveElasticsearchClusterConfiguration"
          }
        },
        "kibana_clusters": {
          "type": "array",
          "description": "Optional list of Kibana clusters to move off the allocator. If not specified, then all Kibana clusters on the allocator are moved.",
          "items": {
            "$ref": "#/definitions/MoveKibanaClusterConfiguration"
          }
        }
      },
      "description": "Configuration for moving clusters off an allocator"
    },
    "MoveElasticsearchClusterConfiguration": {
      "type": "object",
      "required": [
        "cluster_ids"
      ],
      "properties": {
        "cluster_ids": {
          "type": "array",
          "description": "Identifiers for the Elasticsearch clusters.",
          "items": {
            "type": "string"
          }
        },
        "plan_override": {
          "description": "Plan override to apply to the Elasticsearch clusters being moved.",
          "$ref": "#/definitions/TransientElasticsearchPlanConfiguration"
        }
      },
      "description": "Configuration object for moving Elasticsearch clusters."
    },
    "MoveKibanaClusterConfiguration": {
      "type": "object",
      "required": [
        "cluster_ids"
      ],
      "properties": {
        "cluster_ids": {
          "type": "array",
          "description": "Identifiers for the Kibana clusters.",
          "items": {
            "type": "string"
          }
        },
        "plan_override": {
          "description": "Plan override to apply to the Kibana clusters being moved.",
          "$ref": "#/definitions/TransientKibanaPlanConfiguration"
        }
      },
      "description": "Configuration object for moving Kibana clusters."
    },
    "AllocatorMetadataItem": {
      "type": "object",
      "required": [
        "key",
        "value"
      ],
      "properties": {
        "key": {
          "type": "string",
          "description": "The metadata field name"
        },
        "value": {
          "type": "string",
          "description": "The metadata value"
        }
      },
      "description": "Represents an allocator metadata item as a key/value pair"
    },
    "AllocatorMetadataItems": {
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "items": {
          "type": "array",
          "description": "Arbitrary metadata associated with an allocator",
          "items": {
            "$ref": "#/definitions/AllocatorMetadataItem"
          }
        }
      },
      "description": "A container object for allocator metadata items"
    },
    "AllocatorMetadataItemValue": {
      "type": "object",
      "required": [
        "value"
      ],
      "properties": {
        "value": {
          "type": "string",
          "description": "The metadata value"
        }
      },
      "description": "Represents only the value of an allocator metadata item, primarily used for adding a single item where the key is provided in the URL."
    },
    "AllocatedInstanceStatus": {
      "type": "object",
      "properties": {
        "cluster_type": {
          "type": "string",
          "description": "Type of instance that is running. E.g. elasticsearch, kibana"
        },
        "cluster_id": {
          "type": "string",
          "description": "Identifier for the cluster this instance belongs"
        },
        "cluster_name": {
          "type": "string",
          "description": "Name of cluster this instance belongs, if available"
        },
        "instance_name": {
          "type": "string",
          "description": "Instance ID of the instance"
        },
        "node_memory": {
          "type": "integer",
          "format": "int32",
          "description": "Memory assigned to this instance"
        },
        "healthy": {
          "type": "boolean",
          "description": "Indicates whether the instance is healthy"
        },
        "cluster_healthy": {
          "type": "boolean",
          "description": "Indicates whether the cluster the instance belongs to is healthy"
        }
      },
      "description": "Status for an allocated instance"
    },
    "AllocatorCapacity": {
      "type": "object",
      "properties": {
        "memory": {
          "$ref": "#/definitions/AllocatorCapacityMemory"
        }
      },
      "description": "The current total and used capacity for this allocator"
    },
    "AllocatorCapacityMemory": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total memory in MB capacity installed on this allocator"
        },
        "used": {
          "type": "integer",
          "format": "int32",
          "description": "Used memory in MB used by instances assigned to this allocator"
        }
      },
      "description": "Current view of the available and used memory of this allocator"
    },
    "AllocatorHealthStatus": {
      "type": "object",
      "properties": {
        "connected": {
          "type": "boolean",
          "description": "Whether the allocator is connected"
        },
        "healthy": {
          "type": "boolean",
          "description": "Whether the allocator is healthy, meaning it is either connected or has no instances"
        },
        "maintenance_mode": {
          "type": "boolean",
          "description": "Whether the allocator is in maintenance mode (meaning that new workload won't be assigned to it)"
        }
      },
      "description": "Status of this allocator"
    },
    "AllocatorInfo": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/AllocatorHealthStatus"
        },
        "allocator_id": {
          "type": "string",
          "description": "Identifier for this allocator"
        },
        "zone_id": {
          "type": "string",
          "description": "Identifier of the zone"
        },
        "host_ip": {
          "type": "string",
          "description": "Host IP of this allocator"
        },
        "public_hostname": {
          "type": "string",
          "description": "Public hostname of this allocator"
        },
        "capacity": {
          "$ref": "#/definitions/AllocatorCapacity"
        },
        "settings": {
          "$ref": "#/definitions/AllocatorSettings"
        },
        "instances": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AllocatedInstanceStatus"
          }
        },
        "metadata": {
          "type": "array",
          "description": "Arbitrary metadata associated with this allocator",
          "items": {
            "$ref": "#/definitions/AllocatorMetadataItem"
          }
        },
        "features": {
          "type": "array",
          "description": "List of features associated with this allocator. Note this is only present for backwards compatibility purposes and is scheduled for removal in the next major version release.",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "Information about a given allocator"
    },
    "AllocatorOverview": {
      "type": "object",
      "properties": {
        "zones": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AllocatorZoneInfo"
          }
        }
      },
      "description": "Overview over all installed allocators"
    },
    "AllocatorZoneInfo": {
      "type": "object",
      "properties": {
        "zone_id": {
          "type": "string",
          "description": "Identifier of the zone"
        },
        "allocators": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AllocatorInfo"
          }
        }
      },
      "description": "List of allocators in a zone"
    },
    "BoolQuery": {
      "type": "object",
      "properties": {
        "must": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/QueryContainer"
          }
        },
        "should": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/QueryContainer"
          }
        },
        "must_not": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/QueryContainer"
          }
        },
        "filter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/QueryContainer"
          }
        },
        "minimum_should_match": {
          "type": "integer",
          "format": "int32",
          "description": "The minimum number of optional should clauses to match."
        }
      },
      "description": "A query that matches documents matching boolean combinations of other queries."
    },
    "MatchQuery": {
      "type": "object",
      "required": [
        "query"
      ],
      "properties": {
        "query": {
          "type": "string",
          "description": "The text/numeric/date to query for."
        },
        "operator": {
          "type": "string",
          "description": "The operator flag can be set to or or and to control the boolean clauses (defaults to or)."
        },
        "minimum_should_match": {
          "type": "integer",
          "format": "int32",
          "description": "The minimum number of optional should clauses to match."
        },
        "analyzer": {
          "type": "string",
          "description": "The analyzer that will be used to perform the analysis process on the text. Defaults to the analyzer that was used to index the field."
        }
      },
      "description": "Match queries accept text/numerics/dates, analyzes them, and constructs a query."
    },
    "NestedQuery": {
      "type": "object",
      "required": [
        "path",
        "query"
      ],
      "properties": {
        "query": {
          "description": "The actual query to execute on the nested objects.",
          "$ref": "#/definitions/QueryContainer"
        },
        "path": {
          "type": "string",
          "description": "The path to the nested object."
        },
        "score_mode": {
          "type": "string",
          "description": "Allows to specify how inner children matching affects score of the parent. Refer to the Elasticsearch documentation for details.",
          "enum": [
            "avg",
            "sum",
            "min",
            "max",
            "none"
          ]
        }
      },
      "description": "A query that is applicable to nested objects."
    },
    "QueryContainer": {
      "type": "object",
      "properties": {
        "match": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/MatchQuery"
          }
        },
        "term": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/TermQuery"
          }
        },
        "bool": {
          "$ref": "#/definitions/BoolQuery"
        },
        "query_string": {
          "$ref": "#/definitions/QueryStringQuery"
        },
        "nested": {
          "$ref": "#/definitions/NestedQuery"
        }
      },
      "description": "Container for all of the allowed Elasticsearch queries. Only one can be specified."
    },
    "QueryStringQuery": {
      "type": "object",
      "required": [
        "query"
      ],
      "properties": {
        "query": {
          "type": "string",
          "description": "The actual query to be parsed."
        },
        "default_field": {
          "type": "string",
          "description": "The default field for query terms if no prefix field is specified."
        },
        "analyzer": {
          "type": "string",
          "description": "The analyzer used to analyze each term of the query when creating composite queries."
        },
        "default_operator": {
          "type": "string",
          "description": "The default operator used if no explicit operator is specified."
        },
        "allow_leading_wildcard": {
          "type": "boolean",
          "description": "When set, * or ? are allowed as the first character. Defaults to false."
        }
      },
      "description": "A query that uses the SimpleQueryParser to parse its context."
    },
    "SearchRequest": {
      "type": "object",
      "properties": {
        "from": {
          "type": "integer",
          "format": "int32"
        },
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "The maximum number of search results to return."
        },
        "query": {
          "$ref": "#/definitions/QueryContainer"
        },
        "sort": {
          "type": "array",
          "description": "An array of fields to sort the search results by.",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "Represents an Elasticsearch search request, but with a limited subset of options."
    },
    "TermQuery": {
      "type": "object",
      "required": [
        "value"
      ],
      "properties": {
        "value": {
          "type": "string",
          "description": "The exact value to query for."
        }
      },
      "description": "Finds documents that contain the exact term specified in the inverted index."
    },
    "StackVersionArchiveProcessingError": {
      "type": "object",
      "properties": {
        "stack_version": {
          "type": "string",
          "description": "Version of the stack (ie directory name in archive root)"
        },
        "errors": {
          "$ref": "#/definitions/BasicFailedReply"
        }
      },
      "description": "Provides information about errors that occurred while processing an Elastic Stack version"
    },
    "StackVersionArchiveProcessingResult": {
      "type": "object",
      "properties": {
        "stacks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/StackVersionConfig"
          }
        },
        "errors": {
          "type": "array",
          "description": "Errors occurred while processing the Elastic Stack pack. Key: stack version, Value: List of errors",
          "items": {
            "$ref": "#/definitions/StackVersionArchiveProcessingError"
          }
        }
      },
      "description": "Result of processing the submitted archive"
    },
    "StackVersionConfig": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "description": "Stack version",
          "readOnly": true
        },
        "template": {
          "$ref": "#/definitions/StackVersionTemplateInfo"
        },
        "elasticsearch": {
          "$ref": "#/definitions/StackVersionElasticsearchConfig"
        },
        "kibana": {
          "$ref": "#/definitions/StackVersionKibanaConfig"
        },
        "metadata": {
          "$ref": "#/definitions/StackVersionMetadata"
        },
        "deleted": {
          "type": "boolean",
          "description": "Identifies that the Elastic Stack version is marked for deletion",
          "readOnly": true
        }
      },
      "description": "Details for a stack configuration"
    },
    "StackVersionElasticsearchConfig": {
      "type": "object",
      "required": [
        "blacklist",
        "default_plugins",
        "docker_image",
        "plugins"
      ],
      "properties": {
        "docker_image": {
          "type": "string",
          "description": "Docker image for the Elasticsearch"
        },
        "plugins": {
          "type": "array",
          "description": "List of available plugins",
          "items": {
            "type": "string"
          }
        },
        "default_plugins": {
          "type": "array",
          "description": "List of default plugins",
          "items": {
            "type": "string"
          }
        },
        "blacklist": {
          "type": "array",
          "description": "List of configuration options that cannot be overridden by user settings",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "Elasticsearch related configuration of an Elastic Stack version "
    },
    "StackVersionKibanaConfig": {
      "type": "object",
      "required": [
        "blacklist",
        "docker_image"
      ],
      "properties": {
        "version": {
          "type": "string",
          "description": "Version of Kibana"
        },
        "docker_image": {
          "type": "string",
          "description": "Docker image for the kibana"
        },
        "blacklist": {
          "type": "array",
          "description": "List of configuration options that cannot be overridden by user settings",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "Kibana related configuration of an Elastic Stack version"
    },
    "StackVersionMetadata": {
      "type": "object",
      "properties": {
        "notes": {
          "type": "string",
          "description": "Notes for administrator"
        },
        "pre_release": {
          "type": "boolean",
          "description": "Indicates that the stack pack version is not GA and is not supposed to be used in production"
        },
        "min_platform_version": {
          "type": "string",
          "description": "The minimum version of the platform that the stack pack version is compatible with"
        },
        "schema_version": {
          "type": "integer",
          "format": "int32",
          "description": "The schema version of the stack pack version"
        }
      },
      "description": "Stack Pack's metadata"
    },
    "StackVersionTemplateFileHash": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "File path relative to template's root"
        },
        "hash": {
          "type": "string",
          "description": "SHA-256 hash of a file"
        }
      },
      "description": "Template file hash"
    },
    "StackVersionTemplateInfo": {
      "type": "object",
      "properties": {
        "template_version": {
          "type": "string",
          "description": "Template version",
          "readOnly": true
        },
        "hashes": {
          "type": "array",
          "description": "Relative paths of files with SHA-256 hashes that contains the template",
          "readOnly": true,
          "items": {
            "$ref": "#/definitions/StackVersionTemplateFileHash"
          }
        }
      },
      "description": "Template details for a stack"
    },
    "StackVersionConfigs": {
      "type": "object",
      "required": [
        "stacks"
      ],
      "properties": {
        "stacks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/StackVersionConfig"
          }
        }
      },
      "description": "Collection of Elastic Stack versions"
    },
    "StackVersionConfigPost": {
      "type": "object",
      "properties": {
        "elasticsearch": {
          "$ref": "#/definitions/StackVersionElasticsearchConfig"
        },
        "kibana": {
          "$ref": "#/definitions/StackVersionKibanaConfig"
        },
        "metadata": {
          "$ref": "#/definitions/StackVersionMetadata"
        }
      },
      "description": "Elastic Stack version configuration"
    }
  }
}