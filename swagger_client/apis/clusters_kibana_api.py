# coding: utf-8

"""
    

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

    OpenAPI spec version: 
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class ClustersKibanaApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def cancel_kibana_cluster_pending_plan(self, cluster_id, **kwargs):
        """
        Cancel pending plan
        Cancels the pending plan of a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_kibana_cluster_pending_plan(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool ignore_missing: If true (default false), will return successfully regardless of whether there was a pending plan or not
        :return: EmptyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.cancel_kibana_cluster_pending_plan_with_http_info(cluster_id, **kwargs)
        else:
            (data) = self.cancel_kibana_cluster_pending_plan_with_http_info(cluster_id, **kwargs)
            return data

    def cancel_kibana_cluster_pending_plan_with_http_info(self, cluster_id, **kwargs):
        """
        Cancel pending plan
        Cancels the pending plan of a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_kibana_cluster_pending_plan_with_http_info(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool ignore_missing: If true (default false), will return successfully regardless of whether there was a pending plan or not
        :return: EmptyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'ignore_missing']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_kibana_cluster_pending_plan" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `cancel_kibana_cluster_pending_plan`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []
        if 'ignore_missing' in params:
            query_params.append(('ignore_missing', params['ignore_missing']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/plan/pending', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EmptyResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_kibana_cluster(self, body, **kwargs):
        """
        Create cluster
        Creates a Kibana cluster for a given Elasticsearch cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_kibana_cluster(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CreateKibanaClusterRequest body: The cluster definition (required)
        :param bool validate_only: If true, will just validate the cluster definition but will not perform the creation
        :return: ClusterCrudResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_kibana_cluster_with_http_info(body, **kwargs)
        else:
            (data) = self.create_kibana_cluster_with_http_info(body, **kwargs)
            return data

    def create_kibana_cluster_with_http_info(self, body, **kwargs):
        """
        Create cluster
        Creates a Kibana cluster for a given Elasticsearch cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_kibana_cluster_with_http_info(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param CreateKibanaClusterRequest body: The cluster definition (required)
        :param bool validate_only: If true, will just validate the cluster definition but will not perform the creation
        :return: ClusterCrudResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'validate_only']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_kibana_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_kibana_cluster`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'validate_only' in params:
            query_params.append(('validate_only', params['validate_only']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClusterCrudResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_kibana_cluster(self, cluster_id, **kwargs):
        """
        Delete cluster
        Deletes a Kibana cluster. Requires that you have already successfully issued `_shutdown` command against the cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_kibana_cluster(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :return: EmptyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_kibana_cluster_with_http_info(cluster_id, **kwargs)
        else:
            (data) = self.delete_kibana_cluster_with_http_info(cluster_id, **kwargs)
            return data

    def delete_kibana_cluster_with_http_info(self, cluster_id, **kwargs):
        """
        Delete cluster
        Deletes a Kibana cluster. Requires that you have already successfully issued `_shutdown` command against the cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_kibana_cluster_with_http_info(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :return: EmptyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_kibana_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `delete_kibana_cluster`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EmptyResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_kibana_cluster(self, cluster_id, **kwargs):
        """
        Get cluster
        Retrieves cluster information for a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_cluster(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool show_metadata: Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials
        :param bool show_plans: Whether to include the full current and pending plan information in the response - can be large per cluster
        :param bool show_plan_logs: Whether to include with the current and pending plan information the attempt log - can be very large per cluster
        :param bool show_plan_defaults: If showing plans, whether to show values that are left at their default value (less readable but more informative)
        :return: KibanaClusterInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_kibana_cluster_with_http_info(cluster_id, **kwargs)
        else:
            (data) = self.get_kibana_cluster_with_http_info(cluster_id, **kwargs)
            return data

    def get_kibana_cluster_with_http_info(self, cluster_id, **kwargs):
        """
        Get cluster
        Retrieves cluster information for a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_cluster_with_http_info(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool show_metadata: Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials
        :param bool show_plans: Whether to include the full current and pending plan information in the response - can be large per cluster
        :param bool show_plan_logs: Whether to include with the current and pending plan information the attempt log - can be very large per cluster
        :param bool show_plan_defaults: If showing plans, whether to show values that are left at their default value (less readable but more informative)
        :return: KibanaClusterInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'show_metadata', 'show_plans', 'show_plan_logs', 'show_plan_defaults']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_kibana_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_kibana_cluster`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []
        if 'show_metadata' in params:
            query_params.append(('show_metadata', params['show_metadata']))
        if 'show_plans' in params:
            query_params.append(('show_plans', params['show_plans']))
        if 'show_plan_logs' in params:
            query_params.append(('show_plan_logs', params['show_plan_logs']))
        if 'show_plan_defaults' in params:
            query_params.append(('show_plan_defaults', params['show_plan_defaults']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KibanaClusterInfo',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_kibana_cluster_metadata_raw(self, cluster_id, **kwargs):
        """
        Get cluster metadata
        Advanced use only: Retrieves the internal cluster metadata for a Kibana cluster as free-form JSON.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_cluster_metadata_raw(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_kibana_cluster_metadata_raw_with_http_info(cluster_id, **kwargs)
        else:
            (data) = self.get_kibana_cluster_metadata_raw_with_http_info(cluster_id, **kwargs)
            return data

    def get_kibana_cluster_metadata_raw_with_http_info(self, cluster_id, **kwargs):
        """
        Get cluster metadata
        Advanced use only: Retrieves the internal cluster metadata for a Kibana cluster as free-form JSON.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_cluster_metadata_raw_with_http_info(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_kibana_cluster_metadata_raw" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_kibana_cluster_metadata_raw`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/metadata/raw', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='object',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_kibana_cluster_metadata_settings(self, cluster_id, **kwargs):
        """
        Get cluster metadata settings
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_cluster_metadata_settings(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :return: ClusterMetadataSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_kibana_cluster_metadata_settings_with_http_info(cluster_id, **kwargs)
        else:
            (data) = self.get_kibana_cluster_metadata_settings_with_http_info(cluster_id, **kwargs)
            return data

    def get_kibana_cluster_metadata_settings_with_http_info(self, cluster_id, **kwargs):
        """
        Get cluster metadata settings
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_cluster_metadata_settings_with_http_info(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :return: ClusterMetadataSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_kibana_cluster_metadata_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_kibana_cluster_metadata_settings`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/metadata/settings', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClusterMetadataSettings',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_kibana_cluster_pending_plan(self, cluster_id, **kwargs):
        """
        Get pending plan
        Retrieves the pending plan of a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_cluster_pending_plan(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool show_plan_defaults: Whether to show values that are left at their default value (less readable but more informative)
        :return: KibanaClusterPlan
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_kibana_cluster_pending_plan_with_http_info(cluster_id, **kwargs)
        else:
            (data) = self.get_kibana_cluster_pending_plan_with_http_info(cluster_id, **kwargs)
            return data

    def get_kibana_cluster_pending_plan_with_http_info(self, cluster_id, **kwargs):
        """
        Get pending plan
        Retrieves the pending plan of a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_cluster_pending_plan_with_http_info(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool show_plan_defaults: Whether to show values that are left at their default value (less readable but more informative)
        :return: KibanaClusterPlan
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'show_plan_defaults']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_kibana_cluster_pending_plan" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_kibana_cluster_pending_plan`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []
        if 'show_plan_defaults' in params:
            query_params.append(('show_plan_defaults', params['show_plan_defaults']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/plan/pending', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KibanaClusterPlan',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_kibana_cluster_plan(self, cluster_id, **kwargs):
        """
        Get plan
        Retrieves the active plan of a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_cluster_plan(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool show_plan_defaults: Whether to show values that are left at their default value (less readable but more informative)
        :return: KibanaClusterPlan
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_kibana_cluster_plan_with_http_info(cluster_id, **kwargs)
        else:
            (data) = self.get_kibana_cluster_plan_with_http_info(cluster_id, **kwargs)
            return data

    def get_kibana_cluster_plan_with_http_info(self, cluster_id, **kwargs):
        """
        Get plan
        Retrieves the active plan of a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_cluster_plan_with_http_info(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool show_plan_defaults: Whether to show values that are left at their default value (less readable but more informative)
        :return: KibanaClusterPlan
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'show_plan_defaults']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_kibana_cluster_plan" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_kibana_cluster_plan`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []
        if 'show_plan_defaults' in params:
            query_params.append(('show_plan_defaults', params['show_plan_defaults']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/plan', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KibanaClusterPlan',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_kibana_cluster_plan_activity(self, cluster_id, **kwargs):
        """
        Get plan activity
        Retrieves the current and historical plan information for a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_cluster_plan_activity(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool show_plan_logs: Whether to include with the current/pending/historical plan information the attempt log - can be very large per cluster
        :param bool show_plan_defaults: Whether to show values that are left at their default value (less readable but more informative)
        :return: KibanaClusterPlansInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_kibana_cluster_plan_activity_with_http_info(cluster_id, **kwargs)
        else:
            (data) = self.get_kibana_cluster_plan_activity_with_http_info(cluster_id, **kwargs)
            return data

    def get_kibana_cluster_plan_activity_with_http_info(self, cluster_id, **kwargs):
        """
        Get plan activity
        Retrieves the current and historical plan information for a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_cluster_plan_activity_with_http_info(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool show_plan_logs: Whether to include with the current/pending/historical plan information the attempt log - can be very large per cluster
        :param bool show_plan_defaults: Whether to show values that are left at their default value (less readable but more informative)
        :return: KibanaClusterPlansInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'show_plan_logs', 'show_plan_defaults']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_kibana_cluster_plan_activity" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_kibana_cluster_plan_activity`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []
        if 'show_plan_logs' in params:
            query_params.append(('show_plan_logs', params['show_plan_logs']))
        if 'show_plan_defaults' in params:
            query_params.append(('show_plan_defaults', params['show_plan_defaults']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/plan/activity', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KibanaClusterPlansInfo',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_kibana_clusters(self, **kwargs):
        """
        Get clusters
        Retrieves cluster information for all Kibana clusters.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_clusters(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int _from: The number of clusters to skip over
        :param int size: The maximum number of clusters to return (set to -1 for all clusters - use with care, can result in large responses)
        :param bool show_metadata: Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials
        :param bool show_plans: Whether to include the full current and pending plan information in the response - can be large per cluster
        :param bool show_hidden: Whether to include hidden clusters in the response or not
        :param bool show_plan_defaults: If showing plans, whether to show values that are left at their default value (less readable but more informative)
        :return: KibanaClustersInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_kibana_clusters_with_http_info(**kwargs)
        else:
            (data) = self.get_kibana_clusters_with_http_info(**kwargs)
            return data

    def get_kibana_clusters_with_http_info(self, **kwargs):
        """
        Get clusters
        Retrieves cluster information for all Kibana clusters.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_kibana_clusters_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int _from: The number of clusters to skip over
        :param int size: The maximum number of clusters to return (set to -1 for all clusters - use with care, can result in large responses)
        :param bool show_metadata: Whether to include the full cluster metadata in the response - can be large per cluster and also include credentials
        :param bool show_plans: Whether to include the full current and pending plan information in the response - can be large per cluster
        :param bool show_hidden: Whether to include hidden clusters in the response or not
        :param bool show_plan_defaults: If showing plans, whether to show values that are left at their default value (less readable but more informative)
        :return: KibanaClustersInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['_from', 'size', 'show_metadata', 'show_plans', 'show_hidden', 'show_plan_defaults']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_kibana_clusters" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if '_from' in params:
            query_params.append(('from', params['_from']))
        if 'size' in params:
            query_params.append(('size', params['size']))
        if 'show_metadata' in params:
            query_params.append(('show_metadata', params['show_metadata']))
        if 'show_plans' in params:
            query_params.append(('show_plans', params['show_plans']))
        if 'show_hidden' in params:
            query_params.append(('show_hidden', params['show_hidden']))
        if 'show_plan_defaults' in params:
            query_params.append(('show_plan_defaults', params['show_plan_defaults']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KibanaClustersInfo',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def move_kibana_cluster_instances(self, cluster_id, instance_ids, **kwargs):
        """
        Move instances
        Moves one or more instances belonging to a Kibana cluster
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.move_kibana_cluster_instances(cluster_id, instance_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param list[str] instance_ids: Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances (required)
        :param TransientKibanaPlanConfiguration body: Overrides defaults for the move, including setting the configuration of instances specified in the path
        :param bool ignore_missing: If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error
        :param bool force_update: If true, will cancel any pending plans and overwrite with this move plan, else will error
        :param bool validate_only: If true, will validate the move request and return the calculated plan without actually applying it.
        :return: EmptyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.move_kibana_cluster_instances_with_http_info(cluster_id, instance_ids, **kwargs)
        else:
            (data) = self.move_kibana_cluster_instances_with_http_info(cluster_id, instance_ids, **kwargs)
            return data

    def move_kibana_cluster_instances_with_http_info(self, cluster_id, instance_ids, **kwargs):
        """
        Move instances
        Moves one or more instances belonging to a Kibana cluster
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.move_kibana_cluster_instances_with_http_info(cluster_id, instance_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param list[str] instance_ids: Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances (required)
        :param TransientKibanaPlanConfiguration body: Overrides defaults for the move, including setting the configuration of instances specified in the path
        :param bool ignore_missing: If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error
        :param bool force_update: If true, will cancel any pending plans and overwrite with this move plan, else will error
        :param bool validate_only: If true, will validate the move request and return the calculated plan without actually applying it.
        :return: EmptyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'instance_ids', 'body', 'ignore_missing', 'force_update', 'validate_only']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_kibana_cluster_instances" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `move_kibana_cluster_instances`")
        # verify the required parameter 'instance_ids' is set
        if ('instance_ids' not in params) or (params['instance_ids'] is None):
            raise ValueError("Missing the required parameter `instance_ids` when calling `move_kibana_cluster_instances`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']
        if 'instance_ids' in params:
            path_params['instance_ids'] = params['instance_ids']
            collection_formats['instance_ids'] = 'csv'

        query_params = []
        if 'ignore_missing' in params:
            query_params.append(('ignore_missing', params['ignore_missing']))
        if 'force_update' in params:
            query_params.append(('force_update', params['force_update']))
        if 'validate_only' in params:
            query_params.append(('validate_only', params['validate_only']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/instances/{instance_ids}/_move', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EmptyResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def move_kibana_cluster_instances_advanced(self, body, cluster_id, **kwargs):
        """
        Move instances (advanced)
        Moves one or more instances belonging to a Kibana cluster, with custom configuration posted in the body
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.move_kibana_cluster_instances_advanced(body, cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param TransientKibanaPlanConfiguration body: Overrides defaults for the move, including setting the configuration of instances specified in the path (required)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool ignore_missing: If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error
        :param bool force_update: If true, will cancel any pending plans and overwrite with this move plan, else will error
        :param bool validate_only: If true, will validate the move request and return the calculated plan without actually applying it.
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.move_kibana_cluster_instances_advanced_with_http_info(body, cluster_id, **kwargs)
        else:
            (data) = self.move_kibana_cluster_instances_advanced_with_http_info(body, cluster_id, **kwargs)
            return data

    def move_kibana_cluster_instances_advanced_with_http_info(self, body, cluster_id, **kwargs):
        """
        Move instances (advanced)
        Moves one or more instances belonging to a Kibana cluster, with custom configuration posted in the body
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.move_kibana_cluster_instances_advanced_with_http_info(body, cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param TransientKibanaPlanConfiguration body: Overrides defaults for the move, including setting the configuration of instances specified in the path (required)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool ignore_missing: If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error
        :param bool force_update: If true, will cancel any pending plans and overwrite with this move plan, else will error
        :param bool validate_only: If true, will validate the move request and return the calculated plan without actually applying it.
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id', 'ignore_missing', 'force_update', 'validate_only']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_kibana_cluster_instances_advanced" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `move_kibana_cluster_instances_advanced`")
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `move_kibana_cluster_instances_advanced`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []
        if 'ignore_missing' in params:
            query_params.append(('ignore_missing', params['ignore_missing']))
        if 'force_update' in params:
            query_params.append(('force_update', params['force_update']))
        if 'validate_only' in params:
            query_params.append(('validate_only', params['validate_only']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/instances/_move', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClusterCommandResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def restart_kibana_cluster(self, cluster_id, **kwargs):
        """
        Restart cluster
        Restarts a Kibana cluster. If a cluster is active: this command re-applies the existing plan but applies a \"cluster_reboot\", which issues a Kibana restart command and waits for it to complete. If a cluster is inactive: this command starts it up with the most recent successful plan.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.restart_kibana_cluster(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool cancel_pending: If true, will cancel any pending plans before restarting (else will error)
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.restart_kibana_cluster_with_http_info(cluster_id, **kwargs)
        else:
            (data) = self.restart_kibana_cluster_with_http_info(cluster_id, **kwargs)
            return data

    def restart_kibana_cluster_with_http_info(self, cluster_id, **kwargs):
        """
        Restart cluster
        Restarts a Kibana cluster. If a cluster is active: this command re-applies the existing plan but applies a \"cluster_reboot\", which issues a Kibana restart command and waits for it to complete. If a cluster is inactive: this command starts it up with the most recent successful plan.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.restart_kibana_cluster_with_http_info(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool cancel_pending: If true, will cancel any pending plans before restarting (else will error)
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'cancel_pending']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restart_kibana_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `restart_kibana_cluster`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []
        if 'cancel_pending' in params:
            query_params.append(('cancel_pending', params['cancel_pending']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/_restart', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClusterCommandResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_kibana_cluster_metadata_raw(self, cluster_id, body, **kwargs):
        """
        Set cluster metadata
        Advanced use only: Sets the internal cluster metadata for a Kibana cluster with free-form JSON. Must only be used to set a modified version of the JSON returned from the get version of the metadata.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_kibana_cluster_metadata_raw(cluster_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param str body: The freeform JSON for the cluster (should always be based on the current version retrieved from the GET) (required)
        :param int version: If specified then checks for conflicts against the version of the cluster metadata (returned in 'x-cloud-resource-version' of the GET request)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_kibana_cluster_metadata_raw_with_http_info(cluster_id, body, **kwargs)
        else:
            (data) = self.set_kibana_cluster_metadata_raw_with_http_info(cluster_id, body, **kwargs)
            return data

    def set_kibana_cluster_metadata_raw_with_http_info(self, cluster_id, body, **kwargs):
        """
        Set cluster metadata
        Advanced use only: Sets the internal cluster metadata for a Kibana cluster with free-form JSON. Must only be used to set a modified version of the JSON returned from the get version of the metadata.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_kibana_cluster_metadata_raw_with_http_info(cluster_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param str body: The freeform JSON for the cluster (should always be based on the current version retrieved from the GET) (required)
        :param int version: If specified then checks for conflicts against the version of the cluster metadata (returned in 'x-cloud-resource-version' of the GET request)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'body', 'version']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_kibana_cluster_metadata_raw" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `set_kibana_cluster_metadata_raw`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_kibana_cluster_metadata_raw`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/metadata/raw', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='object',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_kibana_cluster_name(self, cluster_id, new_name, **kwargs):
        """
        Set cluster name
        Sets the name of a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_kibana_cluster_name(cluster_id, new_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param str new_name: The new name for the cluster (required)
        :return: EmptyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_kibana_cluster_name_with_http_info(cluster_id, new_name, **kwargs)
        else:
            (data) = self.set_kibana_cluster_name_with_http_info(cluster_id, new_name, **kwargs)
            return data

    def set_kibana_cluster_name_with_http_info(self, cluster_id, new_name, **kwargs):
        """
        Set cluster name
        Sets the name of a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_kibana_cluster_name_with_http_info(cluster_id, new_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param str new_name: The new name for the cluster (required)
        :return: EmptyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'new_name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_kibana_cluster_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `set_kibana_cluster_name`")
        # verify the required parameter 'new_name' is set
        if ('new_name' not in params) or (params['new_name'] is None):
            raise ValueError("Missing the required parameter `new_name` when calling `set_kibana_cluster_name`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']
        if 'new_name' in params:
            path_params['new_name'] = params['new_name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/metadata/name/{new_name}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='EmptyResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def shutdown_kibana_cluster(self, cluster_id, **kwargs):
        """
        Shut down cluster
        Shuts down a running cluster and removes all nodes belonging to the cluster. The cluster definition is retained. Warning: this will lose all cluster data that is not saved in a snapshot repository.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shutdown_kibana_cluster(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool hide: Hide cluster on shutdown. Hidden clusters are not listed by default.
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.shutdown_kibana_cluster_with_http_info(cluster_id, **kwargs)
        else:
            (data) = self.shutdown_kibana_cluster_with_http_info(cluster_id, **kwargs)
            return data

    def shutdown_kibana_cluster_with_http_info(self, cluster_id, **kwargs):
        """
        Shut down cluster
        Shuts down a running cluster and removes all nodes belonging to the cluster. The cluster definition is retained. Warning: this will lose all cluster data that is not saved in a snapshot repository.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.shutdown_kibana_cluster_with_http_info(cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool hide: Hide cluster on shutdown. Hidden clusters are not listed by default.
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'hide']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shutdown_kibana_cluster" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `shutdown_kibana_cluster`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []
        if 'hide' in params:
            query_params.append(('hide', params['hide']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/_shutdown', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClusterCommandResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def start_kibana_cluster_instances(self, cluster_id, instance_ids, **kwargs):
        """
        Start instances
        Starts the instances belonging to a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.start_kibana_cluster_instances(cluster_id, instance_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param list[str] instance_ids: Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances (required)
        :param bool ignore_missing: If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.start_kibana_cluster_instances_with_http_info(cluster_id, instance_ids, **kwargs)
        else:
            (data) = self.start_kibana_cluster_instances_with_http_info(cluster_id, instance_ids, **kwargs)
            return data

    def start_kibana_cluster_instances_with_http_info(self, cluster_id, instance_ids, **kwargs):
        """
        Start instances
        Starts the instances belonging to a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.start_kibana_cluster_instances_with_http_info(cluster_id, instance_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param list[str] instance_ids: Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances (required)
        :param bool ignore_missing: If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'instance_ids', 'ignore_missing']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_kibana_cluster_instances" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `start_kibana_cluster_instances`")
        # verify the required parameter 'instance_ids' is set
        if ('instance_ids' not in params) or (params['instance_ids'] is None):
            raise ValueError("Missing the required parameter `instance_ids` when calling `start_kibana_cluster_instances`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']
        if 'instance_ids' in params:
            path_params['instance_ids'] = params['instance_ids']
            collection_formats['instance_ids'] = 'csv'

        query_params = []
        if 'ignore_missing' in params:
            query_params.append(('ignore_missing', params['ignore_missing']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/instances/{instance_ids}/_start', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClusterCommandResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def start_kibana_cluster_maintenance_mode(self, cluster_id, instance_ids, **kwargs):
        """
        Start maintenance mode
        Starts maintenance mode of instances belonging to a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.start_kibana_cluster_maintenance_mode(cluster_id, instance_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param list[str] instance_ids: Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances (required)
        :param bool ignore_missing: If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.start_kibana_cluster_maintenance_mode_with_http_info(cluster_id, instance_ids, **kwargs)
        else:
            (data) = self.start_kibana_cluster_maintenance_mode_with_http_info(cluster_id, instance_ids, **kwargs)
            return data

    def start_kibana_cluster_maintenance_mode_with_http_info(self, cluster_id, instance_ids, **kwargs):
        """
        Start maintenance mode
        Starts maintenance mode of instances belonging to a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.start_kibana_cluster_maintenance_mode_with_http_info(cluster_id, instance_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param list[str] instance_ids: Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances (required)
        :param bool ignore_missing: If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'instance_ids', 'ignore_missing']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_kibana_cluster_maintenance_mode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `start_kibana_cluster_maintenance_mode`")
        # verify the required parameter 'instance_ids' is set
        if ('instance_ids' not in params) or (params['instance_ids'] is None):
            raise ValueError("Missing the required parameter `instance_ids` when calling `start_kibana_cluster_maintenance_mode`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']
        if 'instance_ids' in params:
            path_params['instance_ids'] = params['instance_ids']
            collection_formats['instance_ids'] = 'csv'

        query_params = []
        if 'ignore_missing' in params:
            query_params.append(('ignore_missing', params['ignore_missing']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/instances/{instance_ids}/maintenance-mode/_start', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClusterCommandResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def stop_kibana_cluster_instances(self, cluster_id, instance_ids, **kwargs):
        """
        Stop instances
        Stops the instances belonging to a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.stop_kibana_cluster_instances(cluster_id, instance_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param list[str] instance_ids: Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances (required)
        :param bool ignore_missing: If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.stop_kibana_cluster_instances_with_http_info(cluster_id, instance_ids, **kwargs)
        else:
            (data) = self.stop_kibana_cluster_instances_with_http_info(cluster_id, instance_ids, **kwargs)
            return data

    def stop_kibana_cluster_instances_with_http_info(self, cluster_id, instance_ids, **kwargs):
        """
        Stop instances
        Stops the instances belonging to a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.stop_kibana_cluster_instances_with_http_info(cluster_id, instance_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param list[str] instance_ids: Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances (required)
        :param bool ignore_missing: If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'instance_ids', 'ignore_missing']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_kibana_cluster_instances" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `stop_kibana_cluster_instances`")
        # verify the required parameter 'instance_ids' is set
        if ('instance_ids' not in params) or (params['instance_ids'] is None):
            raise ValueError("Missing the required parameter `instance_ids` when calling `stop_kibana_cluster_instances`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']
        if 'instance_ids' in params:
            path_params['instance_ids'] = params['instance_ids']
            collection_formats['instance_ids'] = 'csv'

        query_params = []
        if 'ignore_missing' in params:
            query_params.append(('ignore_missing', params['ignore_missing']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/instances/{instance_ids}/_stop', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClusterCommandResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def stop_kibana_cluster_maintenance_mode(self, cluster_id, instance_ids, **kwargs):
        """
        Stop maintenance mode
        Stops maintenance mode of instances belonging to a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.stop_kibana_cluster_maintenance_mode(cluster_id, instance_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param list[str] instance_ids: Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances (required)
        :param bool ignore_missing: If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.stop_kibana_cluster_maintenance_mode_with_http_info(cluster_id, instance_ids, **kwargs)
        else:
            (data) = self.stop_kibana_cluster_maintenance_mode_with_http_info(cluster_id, instance_ids, **kwargs)
            return data

    def stop_kibana_cluster_maintenance_mode_with_http_info(self, cluster_id, instance_ids, **kwargs):
        """
        Stop maintenance mode
        Stops maintenance mode of instances belonging to a Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.stop_kibana_cluster_maintenance_mode_with_http_info(cluster_id, instance_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param list[str] instance_ids: Optional comma-delimited list of instance identifiers of the Kibana cluster, otherwise will apply to all instances (required)
        :param bool ignore_missing: If true and the instance does not exist then quietly proceed to the next instance, otherwise treated as an error
        :return: ClusterCommandResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'instance_ids', 'ignore_missing']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_kibana_cluster_maintenance_mode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `stop_kibana_cluster_maintenance_mode`")
        # verify the required parameter 'instance_ids' is set
        if ('instance_ids' not in params) or (params['instance_ids'] is None):
            raise ValueError("Missing the required parameter `instance_ids` when calling `stop_kibana_cluster_maintenance_mode`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']
        if 'instance_ids' in params:
            path_params['instance_ids'] = params['instance_ids']
            collection_formats['instance_ids'] = 'csv'

        query_params = []
        if 'ignore_missing' in params:
            query_params.append(('ignore_missing', params['ignore_missing']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/instances/{instance_ids}/maintenance-mode/_stop', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClusterCommandResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_kibana_cluster_metadata_settings(self, cluster_id, body, **kwargs):
        """
        Update cluster metadata settings
        Any changes in the PATCHed object will be applied to the metadata object.  PATCHing existing fields will cause same values to be re-applied.PATCHing a value of 'null' will cause the field to be reverted to it's default value or removed if no default value exists
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_kibana_cluster_metadata_settings(cluster_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param ClusterMetadataSettings body: The cluster settings including updated values (required)
        :param int version: If specified then checks for conflicts against the version of the cluster metadata (returned in 'x-cloud-resource-version' of the GET request)
        :return: ClusterMetadataSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_kibana_cluster_metadata_settings_with_http_info(cluster_id, body, **kwargs)
        else:
            (data) = self.update_kibana_cluster_metadata_settings_with_http_info(cluster_id, body, **kwargs)
            return data

    def update_kibana_cluster_metadata_settings_with_http_info(self, cluster_id, body, **kwargs):
        """
        Update cluster metadata settings
        Any changes in the PATCHed object will be applied to the metadata object.  PATCHing existing fields will cause same values to be re-applied.PATCHing a value of 'null' will cause the field to be reverted to it's default value or removed if no default value exists
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_kibana_cluster_metadata_settings_with_http_info(cluster_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param ClusterMetadataSettings body: The cluster settings including updated values (required)
        :param int version: If specified then checks for conflicts against the version of the cluster metadata (returned in 'x-cloud-resource-version' of the GET request)
        :return: ClusterMetadataSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'body', 'version']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_kibana_cluster_metadata_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `update_kibana_cluster_metadata_settings`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_kibana_cluster_metadata_settings`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/metadata/settings', 'PATCH',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClusterMetadataSettings',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_kibana_cluster_plan(self, body, cluster_id, **kwargs):
        """
        Update plan
        Updates the configuration of an existing Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_kibana_cluster_plan(body, cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param KibanaClusterPlan body: The update plan definition (required)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool validate_only: If true, will just validate the cluster definition but will not perform the update
        :return: ClusterCrudResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_kibana_cluster_plan_with_http_info(body, cluster_id, **kwargs)
        else:
            (data) = self.update_kibana_cluster_plan_with_http_info(body, cluster_id, **kwargs)
            return data

    def update_kibana_cluster_plan_with_http_info(self, body, cluster_id, **kwargs):
        """
        Update plan
        Updates the configuration of an existing Kibana cluster.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_kibana_cluster_plan_with_http_info(body, cluster_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param KibanaClusterPlan body: The update plan definition (required)
        :param str cluster_id: Identifier for the Kibana cluster (required)
        :param bool validate_only: If true, will just validate the cluster definition but will not perform the update
        :return: ClusterCrudResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id', 'validate_only']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_kibana_cluster_plan" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_kibana_cluster_plan`")
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params) or (params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `update_kibana_cluster_plan`")


        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['cluster_id'] = params['cluster_id']

        query_params = []
        if 'validate_only' in params:
            query_params.append(('validate_only', params['validate_only']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # Authentication setting
        auth_settings = ['apiKey', 'basicAuth']

        return self.api_client.call_api('/clusters/kibana/{cluster_id}/plan', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClusterCrudResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
